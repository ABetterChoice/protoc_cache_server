// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v5.29.1
// source: cache_server.proto

package protoc_cache_server1

import (
	_ "google.golang.org/genproto/googleapis/api/annotations"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Origin Type
type OriginType int32

const (
	OriginType_ORIGIN_TYPE_UNKNOWN OriginType = 0 // unknow
	OriginType_ORIGIN_TYPE_SERVER  OriginType = 1 // server
	OriginType_ORIGIN_TYPE_MOBILE  OriginType = 2 // terminal
)

// Enum value maps for OriginType.
var (
	OriginType_name = map[int32]string{
		0: "ORIGIN_TYPE_UNKNOWN",
		1: "ORIGIN_TYPE_SERVER",
		2: "ORIGIN_TYPE_MOBILE",
	}
	OriginType_value = map[string]int32{
		"ORIGIN_TYPE_UNKNOWN": 0,
		"ORIGIN_TYPE_SERVER":  1,
		"ORIGIN_TYPE_MOBILE":  2,
	}
)

func (x OriginType) Enum() *OriginType {
	p := new(OriginType)
	*p = x
	return p
}

func (x OriginType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (OriginType) Descriptor() protoreflect.EnumDescriptor {
	return file_cache_server_proto_enumTypes[0].Descriptor()
}

func (OriginType) Type() protoreflect.EnumType {
	return &file_cache_server_proto_enumTypes[0]
}

func (x OriginType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use OriginType.Descriptor instead.
func (OriginType) EnumDescriptor() ([]byte, []int) {
	return file_cache_server_proto_rawDescGZIP(), []int{0}
}

// Update Type
type UpdateType int32

const (
	UpdateType_UPDATE_TYPE_UNKNOWN  UpdateType = 0 // unknow
	UpdateType_UPDATE_TYPE_COMPLETE UpdateType = 1 // COMPLETE
	UpdateType_UPDATE_YPE_DIFF      UpdateType = 2 // Incremental patches
)

// Enum value maps for UpdateType.
var (
	UpdateType_name = map[int32]string{
		0: "UPDATE_TYPE_UNKNOWN",
		1: "UPDATE_TYPE_COMPLETE",
		2: "UPDATE_YPE_DIFF",
	}
	UpdateType_value = map[string]int32{
		"UPDATE_TYPE_UNKNOWN":  0,
		"UPDATE_TYPE_COMPLETE": 1,
		"UPDATE_YPE_DIFF":      2,
	}
)

func (x UpdateType) Enum() *UpdateType {
	p := new(UpdateType)
	*p = x
	return p
}

func (x UpdateType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (UpdateType) Descriptor() protoreflect.EnumDescriptor {
	return file_cache_server_proto_enumTypes[1].Descriptor()
}

func (UpdateType) Type() protoreflect.EnumType {
	return &file_cache_server_proto_enumTypes[1]
}

func (x UpdateType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use UpdateType.Descriptor instead.
func (UpdateType) EnumDescriptor() ([]byte, []int) {
	return file_cache_server_proto_rawDescGZIP(), []int{1}
}

type Code int32

const (
	Code_CODE_SUCCESS            Code = 0    // success
	Code_CODE_NO_PERMISSION      Code = 1001 // NO PERMISSION
	Code_CODE_TRAFFIC_LIMIT      Code = 1002 // TRAFFIC LIMIT
	Code_CODE_INVALID_PROJECT_ID Code = 1003 //  projectID error
	Code_CODE_SERVER_ERR         Code = 1004 // SERVER ERROR
	Code_CODE_INVALID_PARAM      Code = 1005 // INVALID PARAM
	Code_CODE_SAME_VERSION       Code = 2001 // SAME VERSION
)

// Enum value maps for Code.
var (
	Code_name = map[int32]string{
		0:    "CODE_SUCCESS",
		1001: "CODE_NO_PERMISSION",
		1002: "CODE_TRAFFIC_LIMIT",
		1003: "CODE_INVALID_PROJECT_ID",
		1004: "CODE_SERVER_ERR",
		1005: "CODE_INVALID_PARAM",
		2001: "CODE_SAME_VERSION",
	}
	Code_value = map[string]int32{
		"CODE_SUCCESS":            0,
		"CODE_NO_PERMISSION":      1001,
		"CODE_TRAFFIC_LIMIT":      1002,
		"CODE_INVALID_PROJECT_ID": 1003,
		"CODE_SERVER_ERR":         1004,
		"CODE_INVALID_PARAM":      1005,
		"CODE_SAME_VERSION":       2001,
	}
)

func (x Code) Enum() *Code {
	p := new(Code)
	*p = x
	return p
}

func (x Code) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Code) Descriptor() protoreflect.EnumDescriptor {
	return file_cache_server_proto_enumTypes[2].Descriptor()
}

func (Code) Type() protoreflect.EnumType {
	return &file_cache_server_proto_enumTypes[2]
}

func (x Code) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Code.Descriptor instead.
func (Code) EnumDescriptor() ([]byte, []int) {
	return file_cache_server_proto_rawDescGZIP(), []int{2}
}

// hash method
type HashMethod int32

const (
	HashMethod_HASH_METHOD_UNKNOWN HashMethod = 0
	HashMethod_HASH_METHOD_BKDR    HashMethod = 1 // bkdr hash
	HashMethod_HASH_METHOD_MURMUR3 HashMethod = 2 // murmur3
	HashMethod_HASH_METHOD_DJB     HashMethod = 3 // djb
	HashMethod_HASH_METHOD_NEW     HashMethod = 4 // new
	HashMethod_HASH_METHOD_NEW_MD5 HashMethod = 5 // new md5
	HashMethod_HASH_METHOD_AP      HashMethod = 6 // ap
)

// Enum value maps for HashMethod.
var (
	HashMethod_name = map[int32]string{
		0: "HASH_METHOD_UNKNOWN",
		1: "HASH_METHOD_BKDR",
		2: "HASH_METHOD_MURMUR3",
		3: "HASH_METHOD_DJB",
		4: "HASH_METHOD_NEW",
		5: "HASH_METHOD_NEW_MD5",
		6: "HASH_METHOD_AP",
	}
	HashMethod_value = map[string]int32{
		"HASH_METHOD_UNKNOWN": 0,
		"HASH_METHOD_BKDR":    1,
		"HASH_METHOD_MURMUR3": 2,
		"HASH_METHOD_DJB":     3,
		"HASH_METHOD_NEW":     4,
		"HASH_METHOD_NEW_MD5": 5,
		"HASH_METHOD_AP":      6,
	}
)

func (x HashMethod) Enum() *HashMethod {
	p := new(HashMethod)
	*p = x
	return p
}

func (x HashMethod) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (HashMethod) Descriptor() protoreflect.EnumDescriptor {
	return file_cache_server_proto_enumTypes[3].Descriptor()
}

func (HashMethod) Type() protoreflect.EnumType {
	return &file_cache_server_proto_enumTypes[3]
}

func (x HashMethod) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use HashMethod.Descriptor instead.
func (HashMethod) EnumDescriptor() ([]byte, []int) {
	return file_cache_server_proto_rawDescGZIP(), []int{3}
}

type HashType int32

const (
	HashType_HASH_TYPE_UNKNOWN HashType = 0
	HashType_HASH_TYPE_SINGLE  HashType = 1 // Single hash, do a hash once after entering the layer, and directly determine the hit group
	HashType_HASH_TYPE_DOUBLE  HashType = 2 // Double hashing: do a hash once after entering the layer to determine the hit experiment, and do another hash within the experiment to determine the hit group
)

// Enum value maps for HashType.
var (
	HashType_name = map[int32]string{
		0: "HASH_TYPE_UNKNOWN",
		1: "HASH_TYPE_SINGLE",
		2: "HASH_TYPE_DOUBLE",
	}
	HashType_value = map[string]int32{
		"HASH_TYPE_UNKNOWN": 0,
		"HASH_TYPE_SINGLE":  1,
		"HASH_TYPE_DOUBLE":  2,
	}
)

func (x HashType) Enum() *HashType {
	p := new(HashType)
	*p = x
	return p
}

func (x HashType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (HashType) Descriptor() protoreflect.EnumDescriptor {
	return file_cache_server_proto_enumTypes[4].Descriptor()
}

func (HashType) Type() protoreflect.EnumType {
	return &file_cache_server_proto_enumTypes[4]
}

func (x HashType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use HashType.Descriptor instead.
func (HashType) EnumDescriptor() ([]byte, []int) {
	return file_cache_server_proto_rawDescGZIP(), []int{4}
}

type TagOrigin int32

const (
	TagOrigin_TAG_ORIGIN_UNKNOWN TagOrigin = 0 // unknown
	TagOrigin_TAG_ORIGIN_TAG     TagOrigin = 1 // 普通标签
	TagOrigin_TAG_ORIGIN_DMP     TagOrigin = 2 // 人群包
)

// Enum value maps for TagOrigin.
var (
	TagOrigin_name = map[int32]string{
		0: "TAG_ORIGIN_UNKNOWN",
		1: "TAG_ORIGIN_TAG",
		2: "TAG_ORIGIN_DMP",
	}
	TagOrigin_value = map[string]int32{
		"TAG_ORIGIN_UNKNOWN": 0,
		"TAG_ORIGIN_TAG":     1,
		"TAG_ORIGIN_DMP":     2,
	}
)

func (x TagOrigin) Enum() *TagOrigin {
	p := new(TagOrigin)
	*p = x
	return p
}

func (x TagOrigin) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TagOrigin) Descriptor() protoreflect.EnumDescriptor {
	return file_cache_server_proto_enumTypes[5].Descriptor()
}

func (TagOrigin) Type() protoreflect.EnumType {
	return &file_cache_server_proto_enumTypes[5]
}

func (x TagOrigin) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TagOrigin.Descriptor instead.
func (TagOrigin) EnumDescriptor() ([]byte, []int) {
	return file_cache_server_proto_rawDescGZIP(), []int{5}
}

// operator
type Operator int32

const (
	Operator_OPERATOR_UNKNOWN   Operator = 0
	Operator_OPERATOR_EQ        Operator = 1  // equal
	Operator_OPERATOR_LT        Operator = 2  // Less than
	Operator_OPERATOR_LTE       Operator = 3  // Less than or equal to
	Operator_OPERATOR_GT        Operator = 4  // more than
	Operator_OPERATOR_GTE       Operator = 5  // greater or equal to
	Operator_OPERATOR_NE        Operator = 6  // not equal to
	Operator_OPERATOR_REGULAR   Operator = 7  // Regular
	Operator_OPERATOR_IN        Operator = 8  // Exists in array
	Operator_OPERATOR_NOT_IN    Operator = 9  // not exist in the array
	Operator_OPERATOR_SUPER_SET Operator = 10 // Superset
	Operator_OPERATOR_SUB_SET   Operator = 11 // Subset
	Operator_OPERATOR_TRUE      Operator = 12 // true bool，It can also be a crowd package hit
	Operator_OPERATOR_FALSE     Operator = 13 // false bool，It can also be that the crowd package does not hit, take non
	Operator_OPERATOR_LORO      Operator = 14 // Although it can be expressed by Left < X && X < Right, since this is a common expression, we provide interval calculation.
	Operator_OPERATOR_LORC      Operator = 15 // Left open right closed
	Operator_OPERATOR_LCRO      Operator = 16 // Left closed, right open
	Operator_OPERATOR_LCRC      Operator = 17 // Left closed right closed
	Operator_OPERATOR_EMPTY     Operator = 18 // Empty: the tag value passed in by the user is empty
	Operator_OPERATOR_NOT_EMPTY Operator = 19 // Not empty. The tag value passed in by the user is not empty.
	Operator_OPERATOR_LIKE      Operator = 20 // Like: The tag value passed in by the user contains the specified substring.
	Operator_OPERATOR_NOT_LIKE  Operator = 21 // Not Like: The tag value passed in by the user does not contain the specified substring.
)

// Enum value maps for Operator.
var (
	Operator_name = map[int32]string{
		0:  "OPERATOR_UNKNOWN",
		1:  "OPERATOR_EQ",
		2:  "OPERATOR_LT",
		3:  "OPERATOR_LTE",
		4:  "OPERATOR_GT",
		5:  "OPERATOR_GTE",
		6:  "OPERATOR_NE",
		7:  "OPERATOR_REGULAR",
		8:  "OPERATOR_IN",
		9:  "OPERATOR_NOT_IN",
		10: "OPERATOR_SUPER_SET",
		11: "OPERATOR_SUB_SET",
		12: "OPERATOR_TRUE",
		13: "OPERATOR_FALSE",
		14: "OPERATOR_LORO",
		15: "OPERATOR_LORC",
		16: "OPERATOR_LCRO",
		17: "OPERATOR_LCRC",
		18: "OPERATOR_EMPTY",
		19: "OPERATOR_NOT_EMPTY",
		20: "OPERATOR_LIKE",
		21: "OPERATOR_NOT_LIKE",
	}
	Operator_value = map[string]int32{
		"OPERATOR_UNKNOWN":   0,
		"OPERATOR_EQ":        1,
		"OPERATOR_LT":        2,
		"OPERATOR_LTE":       3,
		"OPERATOR_GT":        4,
		"OPERATOR_GTE":       5,
		"OPERATOR_NE":        6,
		"OPERATOR_REGULAR":   7,
		"OPERATOR_IN":        8,
		"OPERATOR_NOT_IN":    9,
		"OPERATOR_SUPER_SET": 10,
		"OPERATOR_SUB_SET":   11,
		"OPERATOR_TRUE":      12,
		"OPERATOR_FALSE":     13,
		"OPERATOR_LORO":      14,
		"OPERATOR_LORC":      15,
		"OPERATOR_LCRO":      16,
		"OPERATOR_LCRC":      17,
		"OPERATOR_EMPTY":     18,
		"OPERATOR_NOT_EMPTY": 19,
		"OPERATOR_LIKE":      20,
		"OPERATOR_NOT_LIKE":  21,
	}
)

func (x Operator) Enum() *Operator {
	p := new(Operator)
	*p = x
	return p
}

func (x Operator) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Operator) Descriptor() protoreflect.EnumDescriptor {
	return file_cache_server_proto_enumTypes[6].Descriptor()
}

func (Operator) Type() protoreflect.EnumType {
	return &file_cache_server_proto_enumTypes[6]
}

func (x Operator) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Operator.Descriptor instead.
func (Operator) EnumDescriptor() ([]byte, []int) {
	return file_cache_server_proto_rawDescGZIP(), []int{6}
}

type TagType int32

const (
	TagType_TAG_TYPE_UNKNOWN TagType = 0
	TagType_TAG_TYPE_STRING  TagType = 1 // string
	TagType_TAG_TYPE_NUMBER  TagType = 2 // number
	TagType_TAG_TYPE_SET     TagType = 3 // set
	TagType_TAG_TYPE_BOOLEAN TagType = 4 // bool
	TagType_TAG_TYPE_DMP     TagType = 5
	TagType_TAG_TYPE_VERSION TagType = 6
	TagType_TAG_TYPE_EMPTY   TagType = 7
)

// Enum value maps for TagType.
var (
	TagType_name = map[int32]string{
		0: "TAG_TYPE_UNKNOWN",
		1: "TAG_TYPE_STRING",
		2: "TAG_TYPE_NUMBER",
		3: "TAG_TYPE_SET",
		4: "TAG_TYPE_BOOLEAN",
		5: "TAG_TYPE_DMP",
		6: "TAG_TYPE_VERSION",
		7: "TAG_TYPE_EMPTY",
	}
	TagType_value = map[string]int32{
		"TAG_TYPE_UNKNOWN": 0,
		"TAG_TYPE_STRING":  1,
		"TAG_TYPE_NUMBER":  2,
		"TAG_TYPE_SET":     3,
		"TAG_TYPE_BOOLEAN": 4,
		"TAG_TYPE_DMP":     5,
		"TAG_TYPE_VERSION": 6,
		"TAG_TYPE_EMPTY":   7,
	}
)

func (x TagType) Enum() *TagType {
	p := new(TagType)
	*p = x
	return p
}

func (x TagType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TagType) Descriptor() protoreflect.EnumDescriptor {
	return file_cache_server_proto_enumTypes[7].Descriptor()
}

func (TagType) Type() protoreflect.EnumType {
	return &file_cache_server_proto_enumTypes[7]
}

func (x TagType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TagType.Descriptor instead.
func (TagType) EnumDescriptor() ([]byte, []int) {
	return file_cache_server_proto_rawDescGZIP(), []int{7}
}

type IssueType int32

const (
	IssueType_ISSUE_TYPE_UNKNOWN    IssueType = 0
	IssueType_ISSUE_TYPE_PERCENTAGE IssueType = 1
	IssueType_ISSUE_TYPE_TAG        IssueType = 2
	IssueType_ISSUE_TYPE_CITY_TAG   IssueType = 3
)

// Enum value maps for IssueType.
var (
	IssueType_name = map[int32]string{
		0: "ISSUE_TYPE_UNKNOWN",
		1: "ISSUE_TYPE_PERCENTAGE",
		2: "ISSUE_TYPE_TAG",
		3: "ISSUE_TYPE_CITY_TAG",
	}
	IssueType_value = map[string]int32{
		"ISSUE_TYPE_UNKNOWN":    0,
		"ISSUE_TYPE_PERCENTAGE": 1,
		"ISSUE_TYPE_TAG":        2,
		"ISSUE_TYPE_CITY_TAG":   3,
	}
)

func (x IssueType) Enum() *IssueType {
	p := new(IssueType)
	*p = x
	return p
}

func (x IssueType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (IssueType) Descriptor() protoreflect.EnumDescriptor {
	return file_cache_server_proto_enumTypes[8].Descriptor()
}

func (IssueType) Type() protoreflect.EnumType {
	return &file_cache_server_proto_enumTypes[8]
}

func (x IssueType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use IssueType.Descriptor instead.
func (IssueType) EnumDescriptor() ([]byte, []int) {
	return file_cache_server_proto_rawDescGZIP(), []int{8}
}

type DomainType int32

const (
	DomainType_DOMAIN_TYPE_UNKNOWN    DomainType = 0
	DomainType_DOMAIN_TYPE_DOMAIN     DomainType = 1
	DomainType_DOMAIN_TYPE_HOLDOUT    DomainType = 2
	DomainType_DOMAIN_TYPE_MULTILAYER DomainType = 3
)

// Enum value maps for DomainType.
var (
	DomainType_name = map[int32]string{
		0: "DOMAIN_TYPE_UNKNOWN",
		1: "DOMAIN_TYPE_DOMAIN",
		2: "DOMAIN_TYPE_HOLDOUT",
		3: "DOMAIN_TYPE_MULTILAYER",
	}
	DomainType_value = map[string]int32{
		"DOMAIN_TYPE_UNKNOWN":    0,
		"DOMAIN_TYPE_DOMAIN":     1,
		"DOMAIN_TYPE_HOLDOUT":    2,
		"DOMAIN_TYPE_MULTILAYER": 3,
	}
)

func (x DomainType) Enum() *DomainType {
	p := new(DomainType)
	*p = x
	return p
}

func (x DomainType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (DomainType) Descriptor() protoreflect.EnumDescriptor {
	return file_cache_server_proto_enumTypes[9].Descriptor()
}

func (DomainType) Type() protoreflect.EnumType {
	return &file_cache_server_proto_enumTypes[9]
}

func (x DomainType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use DomainType.Descriptor instead.
func (DomainType) EnumDescriptor() ([]byte, []int) {
	return file_cache_server_proto_rawDescGZIP(), []int{9}
}

type UnitIDType int32

const (
	UnitIDType_UNIT_ID_TYPE_UNKNOWN UnitIDType = 0
	UnitIDType_UNIT_ID_TYPE_DEFAULT UnitIDType = 1
	UnitIDType_UNIT_ID_TYPE_NEW_ID  UnitIDType = 2
)

// Enum value maps for UnitIDType.
var (
	UnitIDType_name = map[int32]string{
		0: "UNIT_ID_TYPE_UNKNOWN",
		1: "UNIT_ID_TYPE_DEFAULT",
		2: "UNIT_ID_TYPE_NEW_ID",
	}
	UnitIDType_value = map[string]int32{
		"UNIT_ID_TYPE_UNKNOWN": 0,
		"UNIT_ID_TYPE_DEFAULT": 1,
		"UNIT_ID_TYPE_NEW_ID":  2,
	}
)

func (x UnitIDType) Enum() *UnitIDType {
	p := new(UnitIDType)
	*p = x
	return p
}

func (x UnitIDType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (UnitIDType) Descriptor() protoreflect.EnumDescriptor {
	return file_cache_server_proto_enumTypes[10].Descriptor()
}

func (UnitIDType) Type() protoreflect.EnumType {
	return &file_cache_server_proto_enumTypes[10]
}

func (x UnitIDType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use UnitIDType.Descriptor instead.
func (UnitIDType) EnumDescriptor() ([]byte, []int) {
	return file_cache_server_proto_rawDescGZIP(), []int{10}
}

type LayerType int32

const (
	LayerType_LAYER_ORIGIN_UNKNOWN LayerType = 0
	LayerType_LAYER_ORIGIN_EXP     LayerType = 1
	LayerType_LAYER_ORIGIN_CONFIG  LayerType = 2
	LayerType_LAYER_ORIGIN_HOLDOUT LayerType = 3
)

// Enum value maps for LayerType.
var (
	LayerType_name = map[int32]string{
		0: "LAYER_ORIGIN_UNKNOWN",
		1: "LAYER_ORIGIN_EXP",
		2: "LAYER_ORIGIN_CONFIG",
		3: "LAYER_ORIGIN_HOLDOUT",
	}
	LayerType_value = map[string]int32{
		"LAYER_ORIGIN_UNKNOWN": 0,
		"LAYER_ORIGIN_EXP":     1,
		"LAYER_ORIGIN_CONFIG":  2,
		"LAYER_ORIGIN_HOLDOUT": 3,
	}
)

func (x LayerType) Enum() *LayerType {
	p := new(LayerType)
	*p = x
	return p
}

func (x LayerType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (LayerType) Descriptor() protoreflect.EnumDescriptor {
	return file_cache_server_proto_enumTypes[11].Descriptor()
}

func (LayerType) Type() protoreflect.EnumType {
	return &file_cache_server_proto_enumTypes[11]
}

func (x LayerType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use LayerType.Descriptor instead.
func (LayerType) EnumDescriptor() ([]byte, []int) {
	return file_cache_server_proto_rawDescGZIP(), []int{11}
}

type RemoteConfigValueType int32

const (
	RemoteConfigValueType_REMOTE_CONFIG_VALUE_TYPE_UNKNOWN RemoteConfigValueType = 0
	RemoteConfigValueType_REMOTE_CONFIG_VALUE_TYPE_BOOL    RemoteConfigValueType = 1
	RemoteConfigValueType_REMOTE_CONFIG_VALUE_TYPE_BYTES   RemoteConfigValueType = 2
	RemoteConfigValueType_REMOTE_CONFIG_VALUE_TYPE_URL     RemoteConfigValueType = 3
)

// Enum value maps for RemoteConfigValueType.
var (
	RemoteConfigValueType_name = map[int32]string{
		0: "REMOTE_CONFIG_VALUE_TYPE_UNKNOWN",
		1: "REMOTE_CONFIG_VALUE_TYPE_BOOL",
		2: "REMOTE_CONFIG_VALUE_TYPE_BYTES",
		3: "REMOTE_CONFIG_VALUE_TYPE_URL",
	}
	RemoteConfigValueType_value = map[string]int32{
		"REMOTE_CONFIG_VALUE_TYPE_UNKNOWN": 0,
		"REMOTE_CONFIG_VALUE_TYPE_BOOL":    1,
		"REMOTE_CONFIG_VALUE_TYPE_BYTES":   2,
		"REMOTE_CONFIG_VALUE_TYPE_URL":     3,
	}
)

func (x RemoteConfigValueType) Enum() *RemoteConfigValueType {
	p := new(RemoteConfigValueType)
	*p = x
	return p
}

func (x RemoteConfigValueType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (RemoteConfigValueType) Descriptor() protoreflect.EnumDescriptor {
	return file_cache_server_proto_enumTypes[12].Descriptor()
}

func (RemoteConfigValueType) Type() protoreflect.EnumType {
	return &file_cache_server_proto_enumTypes[12]
}

func (x RemoteConfigValueType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use RemoteConfigValueType.Descriptor instead.
func (RemoteConfigValueType) EnumDescriptor() ([]byte, []int) {
	return file_cache_server_proto_rawDescGZIP(), []int{12}
}

// bitmap or range
type BucketType int32

const (
	BucketType_BUCKET_TYPE_UNKNOWN BucketType = 0
	BucketType_BUCKET_TYPE_BITMAP  BucketType = 1 // bitmap
	BucketType_BUCKET_TYPE_RANGE   BucketType = 2
)

// Enum value maps for BucketType.
var (
	BucketType_name = map[int32]string{
		0: "BUCKET_TYPE_UNKNOWN",
		1: "BUCKET_TYPE_BITMAP",
		2: "BUCKET_TYPE_RANGE",
	}
	BucketType_value = map[string]int32{
		"BUCKET_TYPE_UNKNOWN": 0,
		"BUCKET_TYPE_BITMAP":  1,
		"BUCKET_TYPE_RANGE":   2,
	}
)

func (x BucketType) Enum() *BucketType {
	p := new(BucketType)
	*p = x
	return p
}

func (x BucketType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (BucketType) Descriptor() protoreflect.EnumDescriptor {
	return file_cache_server_proto_enumTypes[13].Descriptor()
}

func (BucketType) Type() protoreflect.EnumType {
	return &file_cache_server_proto_enumTypes[13]
}

func (x BucketType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use BucketType.Descriptor instead.
func (BucketType) EnumDescriptor() ([]byte, []int) {
	return file_cache_server_proto_rawDescGZIP(), []int{13}
}

type ModifyType int32

const (
	ModifyType_MODIFY_UNKNOWN ModifyType = 0
	ModifyType_MODIFY_UPDATE  ModifyType = 1
	ModifyType_MODIFY_DELETE  ModifyType = 2
)

// Enum value maps for ModifyType.
var (
	ModifyType_name = map[int32]string{
		0: "MODIFY_UNKNOWN",
		1: "MODIFY_UPDATE",
		2: "MODIFY_DELETE",
	}
	ModifyType_value = map[string]int32{
		"MODIFY_UNKNOWN": 0,
		"MODIFY_UPDATE":  1,
		"MODIFY_DELETE":  2,
	}
)

func (x ModifyType) Enum() *ModifyType {
	p := new(ModifyType)
	*p = x
	return p
}

func (x ModifyType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ModifyType) Descriptor() protoreflect.EnumDescriptor {
	return file_cache_server_proto_enumTypes[14].Descriptor()
}

func (ModifyType) Type() protoreflect.EnumType {
	return &file_cache_server_proto_enumTypes[14]
}

func (x ModifyType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ModifyType.Descriptor instead.
func (ModifyType) EnumDescriptor() ([]byte, []int) {
	return file_cache_server_proto_rawDescGZIP(), []int{14}
}

// Get remote cache service configuration information
type GetTabConfigReq struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ProjectId     string                 `protobuf:"bytes,1,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`                                                 // Business unique identifier
	Version       string                 `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`                                                                      // Local configuration information version, used for patch delivery. If version is empty, the full version will be pulled.
	UpdateType    UpdateType             `protobuf:"varint,4,opt,name=update_type,json=updateType,proto3,enum=opensource.tab.cache_server.UpdateType" json:"update_type,omitempty"` // Update method
	SdkVersion    string                 `protobuf:"bytes,5,opt,name=sdk_version,json=sdkVersion,proto3" json:"sdk_version,omitempty"`                                              // SDK version information, for example GO_1.6.0
	Region        string                 `protobuf:"bytes,10,opt,name=region,proto3" json:"region,omitempty"`                                                                       // Regional information, different configurations can be issued according to different regions
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetTabConfigReq) Reset() {
	*x = GetTabConfigReq{}
	mi := &file_cache_server_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetTabConfigReq) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetTabConfigReq) ProtoMessage() {}

func (x *GetTabConfigReq) ProtoReflect() protoreflect.Message {
	mi := &file_cache_server_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetTabConfigReq.ProtoReflect.Descriptor instead.
func (*GetTabConfigReq) Descriptor() ([]byte, []int) {
	return file_cache_server_proto_rawDescGZIP(), []int{0}
}

func (x *GetTabConfigReq) GetProjectId() string {
	if x != nil {
		return x.ProjectId
	}
	return ""
}

func (x *GetTabConfigReq) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *GetTabConfigReq) GetUpdateType() UpdateType {
	if x != nil {
		return x.UpdateType
	}
	return UpdateType_UPDATE_TYPE_UNKNOWN
}

func (x *GetTabConfigReq) GetSdkVersion() string {
	if x != nil {
		return x.SdkVersion
	}
	return ""
}

func (x *GetTabConfigReq) GetRegion() string {
	if x != nil {
		return x.Region
	}
	return ""
}

// Get cached data results
type GetTabConfigResp struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	Code             Code                   `protobuf:"varint,1,opt,name=code,proto3,enum=opensource.tab.cache_server.Code" json:"code,omitempty"`             // error code
	Message          string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`                                              // Detailed description
	TabConfigManager *TabConfigManager      `protobuf:"bytes,10,opt,name=tab_config_manager,json=tabConfigManager,proto3" json:"tab_config_manager,omitempty"` // Cached data
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *GetTabConfigResp) Reset() {
	*x = GetTabConfigResp{}
	mi := &file_cache_server_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetTabConfigResp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetTabConfigResp) ProtoMessage() {}

func (x *GetTabConfigResp) ProtoReflect() protoreflect.Message {
	mi := &file_cache_server_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetTabConfigResp.ProtoReflect.Descriptor instead.
func (*GetTabConfigResp) Descriptor() ([]byte, []int) {
	return file_cache_server_proto_rawDescGZIP(), []int{1}
}

func (x *GetTabConfigResp) GetCode() Code {
	if x != nil {
		return x.Code
	}
	return Code_CODE_SUCCESS
}

func (x *GetTabConfigResp) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *GetTabConfigResp) GetTabConfigManager() *TabConfigManager {
	if x != nil {
		return x.TabConfigManager
	}
	return nil
}

// Whitelist - Experiment IDs mapped at each layer
type LayerToGroupID struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// key=layer_key，value= group ID
	LayerToGroupId map[string]int64 `protobuf:"bytes,1,rep,name=layer_to_group_id,json=layerToGroupId,proto3" json:"layer_to_group_id,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *LayerToGroupID) Reset() {
	*x = LayerToGroupID{}
	mi := &file_cache_server_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LayerToGroupID) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LayerToGroupID) ProtoMessage() {}

func (x *LayerToGroupID) ProtoReflect() protoreflect.Message {
	mi := &file_cache_server_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LayerToGroupID.ProtoReflect.Descriptor instead.
func (*LayerToGroupID) Descriptor() ([]byte, []int) {
	return file_cache_server_proto_rawDescGZIP(), []int{2}
}

func (x *LayerToGroupID) GetLayerToGroupId() map[string]int64 {
	if x != nil {
		return x.LayerToGroupId
	}
	return nil
}

// Experimental layer domain structure // TODO The concept of layer domain structure is revealed, encapsulated, and the threshold is lowered
type Domain struct {
	state                protoimpl.MessageState `protogen:"open.v1"`
	Metadata             *DomainMetadata        `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`                                                          // metadata
	HoldoutDomainList    []*HoldoutDomain       `protobuf:"bytes,10,rep,name=holdout_domain_list,json=holdoutDomainList,proto3" json:"holdout_domain_list,omitempty"`            // Run through domain list // TODO The essence is to let some people go through one level and be done with it.
	MultiLayerDomainList []*MultiLayerDomain    `protobuf:"bytes,11,rep,name=multi_layer_domain_list,json=multiLayerDomainList,proto3" json:"multi_layer_domain_list,omitempty"` // Multi-layer domain list
	DomainList           []*Domain              `protobuf:"bytes,12,rep,name=domain_list,json=domainList,proto3" json:"domain_list,omitempty"`                                   // Nested subdomain structure
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *Domain) Reset() {
	*x = Domain{}
	mi := &file_cache_server_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Domain) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Domain) ProtoMessage() {}

func (x *Domain) ProtoReflect() protoreflect.Message {
	mi := &file_cache_server_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Domain.ProtoReflect.Descriptor instead.
func (*Domain) Descriptor() ([]byte, []int) {
	return file_cache_server_proto_rawDescGZIP(), []int{3}
}

func (x *Domain) GetMetadata() *DomainMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *Domain) GetHoldoutDomainList() []*HoldoutDomain {
	if x != nil {
		return x.HoldoutDomainList
	}
	return nil
}

func (x *Domain) GetMultiLayerDomainList() []*MultiLayerDomain {
	if x != nil {
		return x.MultiLayerDomainList
	}
	return nil
}

func (x *Domain) GetDomainList() []*Domain {
	if x != nil {
		return x.DomainList
	}
	return nil
}

// Experimental Layer
type Layer struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	Metadata        *LayerMetadata         `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	GroupIndex      map[int64]*Group       `protobuf:"bytes,10,rep,name=group_index,json=groupIndex,proto3" json:"group_index,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`                // Experiment group index under the layer
	ExperimentIndex map[int64]*Experiment  `protobuf:"bytes,11,rep,name=experiment_index,json=experimentIndex,proto3" json:"experiment_index,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // The index of the experiment list under the layer, the key is the experiment ID, and the value is the experiment
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *Layer) Reset() {
	*x = Layer{}
	mi := &file_cache_server_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Layer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Layer) ProtoMessage() {}

func (x *Layer) ProtoReflect() protoreflect.Message {
	mi := &file_cache_server_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Layer.ProtoReflect.Descriptor instead.
func (*Layer) Descriptor() ([]byte, []int) {
	return file_cache_server_proto_rawDescGZIP(), []int{4}
}

func (x *Layer) GetMetadata() *LayerMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *Layer) GetGroupIndex() map[int64]*Group {
	if x != nil {
		return x.GroupIndex
	}
	return nil
}

func (x *Layer) GetExperimentIndex() map[int64]*Experiment {
	if x != nil {
		return x.ExperimentIndex
	}
	return nil
}

// Experimental information
type Experiment struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	HashMethod    HashMethod             `protobuf:"varint,1,opt,name=hash_method,json=hashMethod,proto3,enum=opensource.tab.cache_server.HashMethod" json:"hash_method,omitempty"`                                         // hash method
	HashSeed      int64                  `protobuf:"varint,2,opt,name=hash_seed,json=hashSeed,proto3" json:"hash_seed,omitempty"`                                                                                           // The seed used for the second hash
	Id            int64                  `protobuf:"varint,3,opt,name=id,proto3" json:"id,omitempty"`                                                                                                                       // experiment ID
	Key           string                 `protobuf:"bytes,4,opt,name=key,proto3" json:"key,omitempty"`                                                                                                                      // experiment key
	BucketSize    int64                  `protobuf:"varint,5,opt,name=bucket_size,json=bucketSize,proto3" json:"bucket_size,omitempty"`                                                                                     // Number of experimental barrels，100/1000/10000/100000
	IssueType     IssueType              `protobuf:"varint,10,opt,name=issue_type,json=issueType,proto3,enum=opensource.tab.cache_server.IssueType" json:"issue_type,omitempty"`                                            // Issue Type
	GroupIdIndex  map[int64]bool         `protobuf:"bytes,11,rep,name=group_id_index,json=groupIdIndex,proto3" json:"group_id_index,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"` // The experimental group index under the experiment, the key is groupID, and the value is always true
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Experiment) Reset() {
	*x = Experiment{}
	mi := &file_cache_server_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Experiment) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Experiment) ProtoMessage() {}

func (x *Experiment) ProtoReflect() protoreflect.Message {
	mi := &file_cache_server_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Experiment.ProtoReflect.Descriptor instead.
func (*Experiment) Descriptor() ([]byte, []int) {
	return file_cache_server_proto_rawDescGZIP(), []int{5}
}

func (x *Experiment) GetHashMethod() HashMethod {
	if x != nil {
		return x.HashMethod
	}
	return HashMethod_HASH_METHOD_UNKNOWN
}

func (x *Experiment) GetHashSeed() int64 {
	if x != nil {
		return x.HashSeed
	}
	return 0
}

func (x *Experiment) GetId() int64 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *Experiment) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *Experiment) GetBucketSize() int64 {
	if x != nil {
		return x.BucketSize
	}
	return 0
}

func (x *Experiment) GetIssueType() IssueType {
	if x != nil {
		return x.IssueType
	}
	return IssueType_ISSUE_TYPE_UNKNOWN
}

func (x *Experiment) GetGroupIdIndex() map[int64]bool {
	if x != nil {
		return x.GroupIdIndex
	}
	return nil
}

// holdout
type HoldoutDomain struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Metadata      *DomainMetadata        `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	LayerList     []*Layer               `protobuf:"bytes,10,rep,name=layer_list,json=layerList,proto3" json:"layer_list,omitempty"` // holdout Theoretically, there is only one layer under the holdout domain, but the SDK protocol supports multiple
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HoldoutDomain) Reset() {
	*x = HoldoutDomain{}
	mi := &file_cache_server_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HoldoutDomain) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HoldoutDomain) ProtoMessage() {}

func (x *HoldoutDomain) ProtoReflect() protoreflect.Message {
	mi := &file_cache_server_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HoldoutDomain.ProtoReflect.Descriptor instead.
func (*HoldoutDomain) Descriptor() ([]byte, []int) {
	return file_cache_server_proto_rawDescGZIP(), []int{6}
}

func (x *HoldoutDomain) GetMetadata() *DomainMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *HoldoutDomain) GetLayerList() []*Layer {
	if x != nil {
		return x.LayerList
	}
	return nil
}

// MultiLayerDomain
type MultiLayerDomain struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Metadata      *DomainMetadata        `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	LayerList     []*Layer               `protobuf:"bytes,10,rep,name=layer_list,json=layerList,proto3" json:"layer_list,omitempty"` // layer_list
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MultiLayerDomain) Reset() {
	*x = MultiLayerDomain{}
	mi := &file_cache_server_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MultiLayerDomain) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MultiLayerDomain) ProtoMessage() {}

func (x *MultiLayerDomain) ProtoReflect() protoreflect.Message {
	mi := &file_cache_server_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MultiLayerDomain.ProtoReflect.Descriptor instead.
func (*MultiLayerDomain) Descriptor() ([]byte, []int) {
	return file_cache_server_proto_rawDescGZIP(), []int{7}
}

func (x *MultiLayerDomain) GetMetadata() *DomainMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *MultiLayerDomain) GetLayerList() []*Layer {
	if x != nil {
		return x.LayerList
	}
	return nil
}

// Experimental group information under the experiment [control group or experimental group]
type Group struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            int64                  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`                                                                                  // Experimental group ID
	GroupKey      string                 `protobuf:"bytes,2,opt,name=group_key,json=groupKey,proto3" json:"group_key,omitempty"`                                                       // Experimental group key
	ExperimentId  int64                  `protobuf:"varint,3,opt,name=experiment_id,json=experimentId,proto3" json:"experiment_id,omitempty"`                                          // experiment ID
	ExperimentKey string                 `protobuf:"bytes,4,opt,name=experiment_key,json=experimentKey,proto3" json:"experiment_key,omitempty"`                                        // experiment key
	Params        map[string]string      `protobuf:"bytes,5,rep,name=params,proto3" json:"params,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // group param
	IsDefault     bool                   `protobuf:"varint,6,opt,name=is_default,json=isDefault,proto3" json:"is_default,omitempty"`                                                   // is_default
	IsControl     bool                   `protobuf:"varint,7,opt,name=is_control,json=isControl,proto3" json:"is_control,omitempty"`                                                   // is_control
	LayerKey      string                 `protobuf:"bytes,8,opt,name=layer_key,json=layerKey,proto3" json:"layer_key,omitempty"`                                                       // Redundant field, storing the layer key
	IssueInfo     *IssueInfo             `protobuf:"bytes,9,opt,name=issue_info,json=issueInfo,proto3" json:"issue_info,omitempty"`                                                    // Send information
	SceneIdList   []int64                `protobuf:"varint,10,rep,packed,name=scene_id_list,json=sceneIdList,proto3" json:"scene_id_list,omitempty"`                                   // scene id list
	UnitIdType    UnitIDType             `protobuf:"varint,11,opt,name=unit_id_type,json=unitIdType,proto3,enum=opensource.tab.cache_server.UnitIDType" json:"unit_id_type,omitempty"` // Redundant fields, account ID system
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Group) Reset() {
	*x = Group{}
	mi := &file_cache_server_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Group) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Group) ProtoMessage() {}

func (x *Group) ProtoReflect() protoreflect.Message {
	mi := &file_cache_server_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Group.ProtoReflect.Descriptor instead.
func (*Group) Descriptor() ([]byte, []int) {
	return file_cache_server_proto_rawDescGZIP(), []int{8}
}

func (x *Group) GetId() int64 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *Group) GetGroupKey() string {
	if x != nil {
		return x.GroupKey
	}
	return ""
}

func (x *Group) GetExperimentId() int64 {
	if x != nil {
		return x.ExperimentId
	}
	return 0
}

func (x *Group) GetExperimentKey() string {
	if x != nil {
		return x.ExperimentKey
	}
	return ""
}

func (x *Group) GetParams() map[string]string {
	if x != nil {
		return x.Params
	}
	return nil
}

func (x *Group) GetIsDefault() bool {
	if x != nil {
		return x.IsDefault
	}
	return false
}

func (x *Group) GetIsControl() bool {
	if x != nil {
		return x.IsControl
	}
	return false
}

func (x *Group) GetLayerKey() string {
	if x != nil {
		return x.LayerKey
	}
	return ""
}

func (x *Group) GetIssueInfo() *IssueInfo {
	if x != nil {
		return x.IssueInfo
	}
	return nil
}

func (x *Group) GetSceneIdList() []int64 {
	if x != nil {
		return x.SceneIdList
	}
	return nil
}

func (x *Group) GetUnitIdType() UnitIDType {
	if x != nil {
		return x.UnitIdType
	}
	return UnitIDType_UNIT_ID_TYPE_UNKNOWN
}

// Experimental information release
type IssueInfo struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	IssueType     IssueType              `protobuf:"varint,1,opt,name=issue_type,json=issueType,proto3,enum=opensource.tab.cache_server.IssueType" json:"issue_type,omitempty"` // issue type
	TagListGroup  []*TagList             `protobuf:"bytes,2,rep,name=tag_list_group,json=tagListGroup,proto3" json:"tag_list_group,omitempty"`                                  // The or relationship between tagList, and the and relationship expression in tagList (A && B && C ...) || (a && b && c ...) || ...
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IssueInfo) Reset() {
	*x = IssueInfo{}
	mi := &file_cache_server_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IssueInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IssueInfo) ProtoMessage() {}

func (x *IssueInfo) ProtoReflect() protoreflect.Message {
	mi := &file_cache_server_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IssueInfo.ProtoReflect.Descriptor instead.
func (*IssueInfo) Descriptor() ([]byte, []int) {
	return file_cache_server_proto_rawDescGZIP(), []int{9}
}

func (x *IssueInfo) GetIssueType() IssueType {
	if x != nil {
		return x.IssueType
	}
	return IssueType_ISSUE_TYPE_UNKNOWN
}

func (x *IssueInfo) GetTagListGroup() []*TagList {
	if x != nil {
		return x.TagListGroup
	}
	return nil
}

type TagList struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TagList       []*Tag                 `protobuf:"bytes,2,rep,name=tag_list,json=tagList,proto3" json:"tag_list,omitempty"` //
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TagList) Reset() {
	*x = TagList{}
	mi := &file_cache_server_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TagList) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TagList) ProtoMessage() {}

func (x *TagList) ProtoReflect() protoreflect.Message {
	mi := &file_cache_server_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TagList.ProtoReflect.Descriptor instead.
func (*TagList) Descriptor() ([]byte, []int) {
	return file_cache_server_proto_rawDescGZIP(), []int{10}
}

func (x *TagList) GetTagList() []*Tag {
	if x != nil {
		return x.TagList
	}
	return nil
}

// tag
type Tag struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Key           string                 `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`                                                                                // tag key，The key in the label kv passed by the user is used to obtain the user label value and compare it with the current configuration label value
	TagType       TagType                `protobuf:"varint,2,opt,name=tag_type,json=tagType,proto3,enum=opensource.tab.cache_server.TagType" json:"tag_type,omitempty"`               // 字string\value\array\bool etc.
	Operator      Operator               `protobuf:"varint,3,opt,name=operator,proto3,enum=opensource.tab.cache_server.Operator" json:"operator,omitempty"`                           // operator lte\gte etc
	Value         string                 `protobuf:"bytes,4,opt,name=value,proto3" json:"value,omitempty"`                                                                            // Tag value, crowd package type identifier crowd package key
	DmpPlatform   int64                  `protobuf:"varint,5,opt,name=dmp_platform,json=dmpPlatform,proto3" json:"dmp_platform,omitempty"`                                            // Crowd pack determination system TODO enum
	UnitIdType    UnitIDType             `protobuf:"varint,6,opt,name=unit_id_type,json=unitIdType,proto3,enum=opensource.tab.cache_server.UnitIDType" json:"unit_id_type,omitempty"` // unit id type
	TagOrigin     TagOrigin              `protobuf:"varint,7,opt,name=tag_origin,json=tagOrigin,proto3,enum=opensource.tab.cache_server.TagOrigin" json:"tag_origin,omitempty"`       // 标签来源
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Tag) Reset() {
	*x = Tag{}
	mi := &file_cache_server_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Tag) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Tag) ProtoMessage() {}

func (x *Tag) ProtoReflect() protoreflect.Message {
	mi := &file_cache_server_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Tag.ProtoReflect.Descriptor instead.
func (*Tag) Descriptor() ([]byte, []int) {
	return file_cache_server_proto_rawDescGZIP(), []int{11}
}

func (x *Tag) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *Tag) GetTagType() TagType {
	if x != nil {
		return x.TagType
	}
	return TagType_TAG_TYPE_UNKNOWN
}

func (x *Tag) GetOperator() Operator {
	if x != nil {
		return x.Operator
	}
	return Operator_OPERATOR_UNKNOWN
}

func (x *Tag) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

func (x *Tag) GetDmpPlatform() int64 {
	if x != nil {
		return x.DmpPlatform
	}
	return 0
}

func (x *Tag) GetUnitIdType() UnitIDType {
	if x != nil {
		return x.UnitIdType
	}
	return UnitIDType_UNIT_ID_TYPE_UNKNOWN
}

func (x *Tag) GetTagOrigin() TagOrigin {
	if x != nil {
		return x.TagOrigin
	}
	return TagOrigin_TAG_ORIGIN_UNKNOWN
}

type DomainMetadata struct {
	state      protoimpl.MessageState `protogen:"open.v1"`
	Key        string                 `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"` // key
	DomainType DomainType             `protobuf:"varint,2,opt,name=domain_type,json=domainType,proto3,enum=opensource.tab.cache_server.DomainType" json:"domain_type,omitempty"`
	HashMethod HashMethod             `protobuf:"varint,3,opt,name=hash_method,json=hashMethod,proto3,enum=opensource.tab.cache_server.HashMethod" json:"hash_method,omitempty"` // hash
	HashSeed   int64                  `protobuf:"varint,4,opt,name=hash_seed,json=hashSeed,proto3" json:"hash_seed,omitempty"`                                                   // hash
	// UnitIDType decisionID Special for diversion + reportID N decisionID -> 1 unitID TODO
	UnitIdType       UnitIDType      `protobuf:"varint,5,opt,name=unit_id_type,json=unitIdType,proto3,enum=opensource.tab.cache_server.UnitIDType" json:"unit_id_type,omitempty"` // The ID type used for diversion, used for grayscale switching of diversion ID (usually account system) TODO
	BucketSize       int64           `protobuf:"varint,6,opt,name=bucket_size,json=bucketSize,proto3" json:"bucket_size,omitempty"`                                               // Number of layer buckets, 100/1000/10000/100000, traffic segmentation granularity of the domain
	TrafficRangeList []*TrafficRange `protobuf:"bytes,10,rep,name=traffic_range_list,json=trafficRangeList,proto3" json:"traffic_range_list,omitempty"`                           // traffic range
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *DomainMetadata) Reset() {
	*x = DomainMetadata{}
	mi := &file_cache_server_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DomainMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DomainMetadata) ProtoMessage() {}

func (x *DomainMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_cache_server_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DomainMetadata.ProtoReflect.Descriptor instead.
func (*DomainMetadata) Descriptor() ([]byte, []int) {
	return file_cache_server_proto_rawDescGZIP(), []int{12}
}

func (x *DomainMetadata) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *DomainMetadata) GetDomainType() DomainType {
	if x != nil {
		return x.DomainType
	}
	return DomainType_DOMAIN_TYPE_UNKNOWN
}

func (x *DomainMetadata) GetHashMethod() HashMethod {
	if x != nil {
		return x.HashMethod
	}
	return HashMethod_HASH_METHOD_UNKNOWN
}

func (x *DomainMetadata) GetHashSeed() int64 {
	if x != nil {
		return x.HashSeed
	}
	return 0
}

func (x *DomainMetadata) GetUnitIdType() UnitIDType {
	if x != nil {
		return x.UnitIdType
	}
	return UnitIDType_UNIT_ID_TYPE_UNKNOWN
}

func (x *DomainMetadata) GetBucketSize() int64 {
	if x != nil {
		return x.BucketSize
	}
	return 0
}

func (x *DomainMetadata) GetTrafficRangeList() []*TrafficRange {
	if x != nil {
		return x.TrafficRangeList
	}
	return nil
}

type LayerMetadata struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	Key              string                 `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	DefaultGroup     *Group                 `protobuf:"bytes,2,opt,name=default_group,json=defaultGroup,proto3" json:"default_group,omitempty"`
	HashType         HashType               `protobuf:"varint,3,opt,name=hash_type,json=hashType,proto3,enum=opensource.tab.cache_server.HashType" json:"hash_type,omitempty"`         // hash type
	HashMethod       HashMethod             `protobuf:"varint,4,opt,name=hash_method,json=hashMethod,proto3,enum=opensource.tab.cache_server.HashMethod" json:"hash_method,omitempty"` // hash
	HashSeed         int64                  `protobuf:"varint,5,opt,name=hash_seed,json=hashSeed,proto3" json:"hash_seed,omitempty"`                                                   // hash seed
	SceneIdList      []int64                `protobuf:"varint,6,rep,packed,name=scene_id_list,json=sceneIdList,proto3" json:"scene_id_list,omitempty"`
	UnitIdType       UnitIDType             `protobuf:"varint,7,opt,name=unit_id_type,json=unitIdType,proto3,enum=opensource.tab.cache_server.UnitIDType" json:"unit_id_type,omitempty"`
	TrafficRangeList []*TrafficRange        `protobuf:"bytes,8,rep,name=traffic_range_list,json=trafficRangeList,proto3" json:"traffic_range_list,omitempty"`                       // TODO No, traffic is controlled by the domain
	BucketSize       int64                  `protobuf:"varint,10,opt,name=bucket_size,json=bucketSize,proto3" json:"bucket_size,omitempty"`                                         // bucket size，100/1000/10000/100000
	HoldoutLayerKeys []string               `protobuf:"bytes,11,rep,name=holdout_layer_keys,json=holdoutLayerKeys,proto3" json:"holdout_layer_keys,omitempty"`                      // Mounted holdout layers, judging from left to right, web guarantees that there will be no loops Layer A holdout layer B, .., layer B holdout layer A
	LayerType        LayerType              `protobuf:"varint,12,opt,name=layer_type,json=layerType,proto3,enum=opensource.tab.cache_server.LayerType" json:"layer_type,omitempty"` // layer type
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *LayerMetadata) Reset() {
	*x = LayerMetadata{}
	mi := &file_cache_server_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LayerMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LayerMetadata) ProtoMessage() {}

func (x *LayerMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_cache_server_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LayerMetadata.ProtoReflect.Descriptor instead.
func (*LayerMetadata) Descriptor() ([]byte, []int) {
	return file_cache_server_proto_rawDescGZIP(), []int{13}
}

func (x *LayerMetadata) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *LayerMetadata) GetDefaultGroup() *Group {
	if x != nil {
		return x.DefaultGroup
	}
	return nil
}

func (x *LayerMetadata) GetHashType() HashType {
	if x != nil {
		return x.HashType
	}
	return HashType_HASH_TYPE_UNKNOWN
}

func (x *LayerMetadata) GetHashMethod() HashMethod {
	if x != nil {
		return x.HashMethod
	}
	return HashMethod_HASH_METHOD_UNKNOWN
}

func (x *LayerMetadata) GetHashSeed() int64 {
	if x != nil {
		return x.HashSeed
	}
	return 0
}

func (x *LayerMetadata) GetSceneIdList() []int64 {
	if x != nil {
		return x.SceneIdList
	}
	return nil
}

func (x *LayerMetadata) GetUnitIdType() UnitIDType {
	if x != nil {
		return x.UnitIdType
	}
	return UnitIDType_UNIT_ID_TYPE_UNKNOWN
}

func (x *LayerMetadata) GetTrafficRangeList() []*TrafficRange {
	if x != nil {
		return x.TrafficRangeList
	}
	return nil
}

func (x *LayerMetadata) GetBucketSize() int64 {
	if x != nil {
		return x.BucketSize
	}
	return 0
}

func (x *LayerMetadata) GetHoldoutLayerKeys() []string {
	if x != nil {
		return x.HoldoutLayerKeys
	}
	return nil
}

func (x *LayerMetadata) GetLayerType() LayerType {
	if x != nil {
		return x.LayerType
	}
	return LayerType_LAYER_ORIGIN_UNKNOWN
}

// Traffic interval range hashValue is in the interval (0, bucket_size], and hitting the closed interval [left,right] is considered a hit
type TrafficRange struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Left          int64                  `protobuf:"varint,1,opt,name=left,proto3" json:"left,omitempty"`
	Right         int64                  `protobuf:"varint,2,opt,name=right,proto3" json:"right,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TrafficRange) Reset() {
	*x = TrafficRange{}
	mi := &file_cache_server_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TrafficRange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TrafficRange) ProtoMessage() {}

func (x *TrafficRange) ProtoReflect() protoreflect.Message {
	mi := &file_cache_server_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TrafficRange.ProtoReflect.Descriptor instead.
func (*TrafficRange) Descriptor() ([]byte, []int) {
	return file_cache_server_proto_rawDescGZIP(), []int{14}
}

func (x *TrafficRange) GetLeft() int64 {
	if x != nil {
		return x.Left
	}
	return 0
}

func (x *TrafficRange) GetRight() int64 {
	if x != nil {
		return x.Right
	}
	return 0
}

type ExperimentData struct {
	state          protoimpl.MessageState     `protogen:"open.v1"`
	DefaultGroupId int64                      `protobuf:"varint,1,opt,name=default_group_id,json=defaultGroupId,proto3" json:"default_group_id,omitempty"`
	OverrideList   map[string]*LayerToGroupID `protobuf:"bytes,2,rep,name=override_list,json=overrideList,proto3" json:"override_list,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	GlobalDomain   *Domain                    `protobuf:"bytes,3,opt,name=global_domain,json=globalDomain,proto3" json:"global_domain,omitempty"`
	HoldoutData    *HoldoutData               `protobuf:"bytes,4,opt,name=holdout_data,json=holdoutData,proto3" json:"holdout_data,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *ExperimentData) Reset() {
	*x = ExperimentData{}
	mi := &file_cache_server_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExperimentData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExperimentData) ProtoMessage() {}

func (x *ExperimentData) ProtoReflect() protoreflect.Message {
	mi := &file_cache_server_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExperimentData.ProtoReflect.Descriptor instead.
func (*ExperimentData) Descriptor() ([]byte, []int) {
	return file_cache_server_proto_rawDescGZIP(), []int{15}
}

func (x *ExperimentData) GetDefaultGroupId() int64 {
	if x != nil {
		return x.DefaultGroupId
	}
	return 0
}

func (x *ExperimentData) GetOverrideList() map[string]*LayerToGroupID {
	if x != nil {
		return x.OverrideList
	}
	return nil
}

func (x *ExperimentData) GetGlobalDomain() *Domain {
	if x != nil {
		return x.GlobalDomain
	}
	return nil
}

func (x *ExperimentData) GetHoldoutData() *HoldoutData {
	if x != nil {
		return x.HoldoutData
	}
	return nil
}

type HoldoutData struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	HoldoutLayerIndex map[string]*Layer      `protobuf:"bytes,1,rep,name=holdout_layer_index,json=holdoutLayerIndex,proto3" json:"holdout_layer_index,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *HoldoutData) Reset() {
	*x = HoldoutData{}
	mi := &file_cache_server_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HoldoutData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HoldoutData) ProtoMessage() {}

func (x *HoldoutData) ProtoReflect() protoreflect.Message {
	mi := &file_cache_server_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HoldoutData.ProtoReflect.Descriptor instead.
func (*HoldoutData) Descriptor() ([]byte, []int) {
	return file_cache_server_proto_rawDescGZIP(), []int{16}
}

func (x *HoldoutData) GetHoldoutLayerIndex() map[string]*Layer {
	if x != nil {
		return x.HoldoutLayerIndex
	}
	return nil
}

type RemoteConfigData struct {
	state             protoimpl.MessageState   `protogen:"open.v1"`
	RemoteConfigIndex map[string]*RemoteConfig `protobuf:"bytes,1,rep,name=remote_config_index,json=remoteConfigIndex,proto3" json:"remote_config_index,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *RemoteConfigData) Reset() {
	*x = RemoteConfigData{}
	mi := &file_cache_server_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RemoteConfigData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RemoteConfigData) ProtoMessage() {}

func (x *RemoteConfigData) ProtoReflect() protoreflect.Message {
	mi := &file_cache_server_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RemoteConfigData.ProtoReflect.Descriptor instead.
func (*RemoteConfigData) Descriptor() ([]byte, []int) {
	return file_cache_server_proto_rawDescGZIP(), []int{17}
}

func (x *RemoteConfigData) GetRemoteConfigIndex() map[string]*RemoteConfig {
	if x != nil {
		return x.RemoteConfigIndex
	}
	return nil
}

type RemoteConfig struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	Key              string                 `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	DefaultValue     []byte                 `protobuf:"bytes,2,opt,name=default_value,json=defaultValue,proto3" json:"default_value,omitempty"`
	Version          string                 `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	SceneIdList      []int64                `protobuf:"varint,4,rep,packed,name=scene_id_list,json=sceneIdList,proto3" json:"scene_id_list,omitempty"`
	Type             RemoteConfigValueType  `protobuf:"varint,5,opt,name=type,proto3,enum=opensource.tab.cache_server.RemoteConfigValueType" json:"type,omitempty"`
	ConditionList    []*Condition           `protobuf:"bytes,6,rep,name=condition_list,json=conditionList,proto3" json:"condition_list,omitempty"`
	OverrideList     map[string][]byte      `protobuf:"bytes,10,rep,name=override_list,json=overrideList,proto3" json:"override_list,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	HoldoutLayerKeys []string               `protobuf:"bytes,11,rep,name=holdout_layer_keys,json=holdoutLayerKeys,proto3" json:"holdout_layer_keys,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *RemoteConfig) Reset() {
	*x = RemoteConfig{}
	mi := &file_cache_server_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RemoteConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RemoteConfig) ProtoMessage() {}

func (x *RemoteConfig) ProtoReflect() protoreflect.Message {
	mi := &file_cache_server_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RemoteConfig.ProtoReflect.Descriptor instead.
func (*RemoteConfig) Descriptor() ([]byte, []int) {
	return file_cache_server_proto_rawDescGZIP(), []int{18}
}

func (x *RemoteConfig) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *RemoteConfig) GetDefaultValue() []byte {
	if x != nil {
		return x.DefaultValue
	}
	return nil
}

func (x *RemoteConfig) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *RemoteConfig) GetSceneIdList() []int64 {
	if x != nil {
		return x.SceneIdList
	}
	return nil
}

func (x *RemoteConfig) GetType() RemoteConfigValueType {
	if x != nil {
		return x.Type
	}
	return RemoteConfigValueType_REMOTE_CONFIG_VALUE_TYPE_UNKNOWN
}

func (x *RemoteConfig) GetConditionList() []*Condition {
	if x != nil {
		return x.ConditionList
	}
	return nil
}

func (x *RemoteConfig) GetOverrideList() map[string][]byte {
	if x != nil {
		return x.OverrideList
	}
	return nil
}

func (x *RemoteConfig) GetHoldoutLayerKeys() []string {
	if x != nil {
		return x.HoldoutLayerKeys
	}
	return nil
}

type Condition struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            int64                  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Key           string                 `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Value         []byte                 `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	HashMethod    HashMethod             `protobuf:"varint,4,opt,name=hash_method,json=hashMethod,proto3,enum=opensource.tab.cache_server.HashMethod" json:"hash_method,omitempty"`
	HashSeed      int64                  `protobuf:"varint,5,opt,name=hash_seed,json=hashSeed,proto3" json:"hash_seed,omitempty"`
	ExperimentKey string                 `protobuf:"bytes,6,opt,name=experiment_key,json=experimentKey,proto3" json:"experiment_key,omitempty"`
	BucketSize    int64                  `protobuf:"varint,7,opt,name=bucket_size,json=bucketSize,proto3" json:"bucket_size,omitempty"`
	BucketInfo    *BucketInfo            `protobuf:"bytes,8,opt,name=bucket_info,json=bucketInfo,proto3" json:"bucket_info,omitempty"`
	UnitIdType    UnitIDType             `protobuf:"varint,9,opt,name=unit_id_type,json=unitIdType,proto3,enum=opensource.tab.cache_server.UnitIDType" json:"unit_id_type,omitempty"`
	IssueInfo     *IssueInfo             `protobuf:"bytes,10,opt,name=issue_info,json=issueInfo,proto3" json:"issue_info,omitempty"`
	ConfigKey     string                 `protobuf:"bytes,11,opt,name=config_key,json=configKey,proto3" json:"config_key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Condition) Reset() {
	*x = Condition{}
	mi := &file_cache_server_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Condition) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Condition) ProtoMessage() {}

func (x *Condition) ProtoReflect() protoreflect.Message {
	mi := &file_cache_server_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Condition.ProtoReflect.Descriptor instead.
func (*Condition) Descriptor() ([]byte, []int) {
	return file_cache_server_proto_rawDescGZIP(), []int{19}
}

func (x *Condition) GetId() int64 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *Condition) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *Condition) GetValue() []byte {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *Condition) GetHashMethod() HashMethod {
	if x != nil {
		return x.HashMethod
	}
	return HashMethod_HASH_METHOD_UNKNOWN
}

func (x *Condition) GetHashSeed() int64 {
	if x != nil {
		return x.HashSeed
	}
	return 0
}

func (x *Condition) GetExperimentKey() string {
	if x != nil {
		return x.ExperimentKey
	}
	return ""
}

func (x *Condition) GetBucketSize() int64 {
	if x != nil {
		return x.BucketSize
	}
	return 0
}

func (x *Condition) GetBucketInfo() *BucketInfo {
	if x != nil {
		return x.BucketInfo
	}
	return nil
}

func (x *Condition) GetUnitIdType() UnitIDType {
	if x != nil {
		return x.UnitIdType
	}
	return UnitIDType_UNIT_ID_TYPE_UNKNOWN
}

func (x *Condition) GetIssueInfo() *IssueInfo {
	if x != nil {
		return x.IssueInfo
	}
	return nil
}

func (x *Condition) GetConfigKey() string {
	if x != nil {
		return x.ConfigKey
	}
	return ""
}

type ControlData struct {
	state                            protoimpl.MessageState        `protogen:"open.v1"`
	RefreshInterval                  uint32                        `protobuf:"varint,1,opt,name=refresh_interval,json=refreshInterval,proto3" json:"refresh_interval,omitempty"`
	IgnoreReportGroupId              map[int64]bool                `protobuf:"bytes,2,rep,name=ignore_report_group_id,json=ignoreReportGroupId,proto3" json:"ignore_report_group_id,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	ExperimentMetricsConfig          map[int64]*MetricsConfig      `protobuf:"bytes,3,rep,name=experiment_metrics_config,json=experimentMetricsConfig,proto3" json:"experiment_metrics_config,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	DefaultExperimentMetricsConfig   *MetricsConfig                `protobuf:"bytes,4,opt,name=default_experiment_metrics_config,json=defaultExperimentMetricsConfig,proto3" json:"default_experiment_metrics_config,omitempty"`
	RemoteConfigMetricsConfig        map[int64]*MetricsConfig      `protobuf:"bytes,5,rep,name=remote_config_metrics_config,json=remoteConfigMetricsConfig,proto3" json:"remote_config_metrics_config,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	DefaultRemoteConfigMetricsConfig *MetricsConfig                `protobuf:"bytes,6,opt,name=default_remote_config_metrics_config,json=defaultRemoteConfigMetricsConfig,proto3" json:"default_remote_config_metrics_config,omitempty"`
	FeatureFlagMetricsConfig         map[int64]*MetricsConfig      `protobuf:"bytes,7,rep,name=feature_flag_metrics_config,json=featureFlagMetricsConfig,proto3" json:"feature_flag_metrics_config,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	DefaultFeatureFlagMetricsConfig  *MetricsConfig                `protobuf:"bytes,8,opt,name=default_feature_flag_metrics_config,json=defaultFeatureFlagMetricsConfig,proto3" json:"default_feature_flag_metrics_config,omitempty"`
	EventMetricsConfig               *MetricsConfig                `protobuf:"bytes,9,opt,name=event_metrics_config,json=eventMetricsConfig,proto3" json:"event_metrics_config,omitempty"`
	MetricsInitConfigIndex           map[string]*MetricsInitConfig `protobuf:"bytes,10,rep,name=metrics_init_config_index,json=metricsInitConfigIndex,proto3" json:"metrics_init_config_index,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields                    protoimpl.UnknownFields
	sizeCache                        protoimpl.SizeCache
}

func (x *ControlData) Reset() {
	*x = ControlData{}
	mi := &file_cache_server_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ControlData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ControlData) ProtoMessage() {}

func (x *ControlData) ProtoReflect() protoreflect.Message {
	mi := &file_cache_server_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ControlData.ProtoReflect.Descriptor instead.
func (*ControlData) Descriptor() ([]byte, []int) {
	return file_cache_server_proto_rawDescGZIP(), []int{20}
}

func (x *ControlData) GetRefreshInterval() uint32 {
	if x != nil {
		return x.RefreshInterval
	}
	return 0
}

func (x *ControlData) GetIgnoreReportGroupId() map[int64]bool {
	if x != nil {
		return x.IgnoreReportGroupId
	}
	return nil
}

func (x *ControlData) GetExperimentMetricsConfig() map[int64]*MetricsConfig {
	if x != nil {
		return x.ExperimentMetricsConfig
	}
	return nil
}

func (x *ControlData) GetDefaultExperimentMetricsConfig() *MetricsConfig {
	if x != nil {
		return x.DefaultExperimentMetricsConfig
	}
	return nil
}

func (x *ControlData) GetRemoteConfigMetricsConfig() map[int64]*MetricsConfig {
	if x != nil {
		return x.RemoteConfigMetricsConfig
	}
	return nil
}

func (x *ControlData) GetDefaultRemoteConfigMetricsConfig() *MetricsConfig {
	if x != nil {
		return x.DefaultRemoteConfigMetricsConfig
	}
	return nil
}

func (x *ControlData) GetFeatureFlagMetricsConfig() map[int64]*MetricsConfig {
	if x != nil {
		return x.FeatureFlagMetricsConfig
	}
	return nil
}

func (x *ControlData) GetDefaultFeatureFlagMetricsConfig() *MetricsConfig {
	if x != nil {
		return x.DefaultFeatureFlagMetricsConfig
	}
	return nil
}

func (x *ControlData) GetEventMetricsConfig() *MetricsConfig {
	if x != nil {
		return x.EventMetricsConfig
	}
	return nil
}

func (x *ControlData) GetMetricsInitConfigIndex() map[string]*MetricsInitConfig {
	if x != nil {
		return x.MetricsInitConfigIndex
	}
	return nil
}

type MetricsConfig struct {
	state               protoimpl.MessageState `protogen:"open.v1"`
	IsAutomatic         bool                   `protobuf:"varint,1,opt,name=is_automatic,json=isAutomatic,proto3" json:"is_automatic,omitempty"`
	IsEnable            bool                   `protobuf:"varint,2,opt,name=is_enable,json=isEnable,proto3" json:"is_enable,omitempty"`
	PluginName          string                 `protobuf:"bytes,3,opt,name=plugin_name,json=pluginName,proto3" json:"plugin_name,omitempty"`
	SceneId             int64                  `protobuf:"varint,4,opt,name=scene_id,json=sceneId,proto3" json:"scene_id,omitempty"`
	SamplingInterval    uint32                 `protobuf:"varint,5,opt,name=sampling_interval,json=samplingInterval,proto3" json:"sampling_interval,omitempty"`
	ErrSamplingInterval uint32                 `protobuf:"varint,6,opt,name=err_sampling_interval,json=errSamplingInterval,proto3" json:"err_sampling_interval,omitempty"`
	Metadata            *MetricsMetadata       `protobuf:"bytes,10,opt,name=metadata,proto3" json:"metadata,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *MetricsConfig) Reset() {
	*x = MetricsConfig{}
	mi := &file_cache_server_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MetricsConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MetricsConfig) ProtoMessage() {}

func (x *MetricsConfig) ProtoReflect() protoreflect.Message {
	mi := &file_cache_server_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MetricsConfig.ProtoReflect.Descriptor instead.
func (*MetricsConfig) Descriptor() ([]byte, []int) {
	return file_cache_server_proto_rawDescGZIP(), []int{21}
}

func (x *MetricsConfig) GetIsAutomatic() bool {
	if x != nil {
		return x.IsAutomatic
	}
	return false
}

func (x *MetricsConfig) GetIsEnable() bool {
	if x != nil {
		return x.IsEnable
	}
	return false
}

func (x *MetricsConfig) GetPluginName() string {
	if x != nil {
		return x.PluginName
	}
	return ""
}

func (x *MetricsConfig) GetSceneId() int64 {
	if x != nil {
		return x.SceneId
	}
	return 0
}

func (x *MetricsConfig) GetSamplingInterval() uint32 {
	if x != nil {
		return x.SamplingInterval
	}
	return 0
}

func (x *MetricsConfig) GetErrSamplingInterval() uint32 {
	if x != nil {
		return x.ErrSamplingInterval
	}
	return 0
}

func (x *MetricsConfig) GetMetadata() *MetricsMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

type MetricsInitConfig struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Region        string                 `protobuf:"bytes,1,opt,name=Region,proto3" json:"Region,omitempty"`
	Addr          string                 `protobuf:"bytes,2,opt,name=addr,proto3" json:"addr,omitempty"`
	Kv            map[string]string      `protobuf:"bytes,3,rep,name=kv,proto3" json:"kv,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MetricsInitConfig) Reset() {
	*x = MetricsInitConfig{}
	mi := &file_cache_server_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MetricsInitConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MetricsInitConfig) ProtoMessage() {}

func (x *MetricsInitConfig) ProtoReflect() protoreflect.Message {
	mi := &file_cache_server_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MetricsInitConfig.ProtoReflect.Descriptor instead.
func (*MetricsInitConfig) Descriptor() ([]byte, []int) {
	return file_cache_server_proto_rawDescGZIP(), []int{22}
}

func (x *MetricsInitConfig) GetRegion() string {
	if x != nil {
		return x.Region
	}
	return ""
}

func (x *MetricsInitConfig) GetAddr() string {
	if x != nil {
		return x.Addr
	}
	return ""
}

func (x *MetricsInitConfig) GetKv() map[string]string {
	if x != nil {
		return x.Kv
	}
	return nil
}

type MetricsMetadata struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ExpandedData  map[string]string      `protobuf:"bytes,1,rep,name=expanded_data,json=expandedData,proto3" json:"expanded_data,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Name          string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Id            string                 `protobuf:"bytes,3,opt,name=id,proto3" json:"id,omitempty"`
	Token         string                 `protobuf:"bytes,4,opt,name=token,proto3" json:"token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MetricsMetadata) Reset() {
	*x = MetricsMetadata{}
	mi := &file_cache_server_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MetricsMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MetricsMetadata) ProtoMessage() {}

func (x *MetricsMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_cache_server_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MetricsMetadata.ProtoReflect.Descriptor instead.
func (*MetricsMetadata) Descriptor() ([]byte, []int) {
	return file_cache_server_proto_rawDescGZIP(), []int{23}
}

func (x *MetricsMetadata) GetExpandedData() map[string]string {
	if x != nil {
		return x.ExpandedData
	}
	return nil
}

func (x *MetricsMetadata) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *MetricsMetadata) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *MetricsMetadata) GetToken() string {
	if x != nil {
		return x.Token
	}
	return ""
}

type TabConfig struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	ExperimentData *ExperimentData        `protobuf:"bytes,1,opt,name=experiment_data,json=experimentData,proto3" json:"experiment_data,omitempty"`
	ConfigData     *RemoteConfigData      `protobuf:"bytes,2,opt,name=config_data,json=configData,proto3" json:"config_data,omitempty"`
	ControlData    *ControlData           `protobuf:"bytes,3,opt,name=control_data,json=controlData,proto3" json:"control_data,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *TabConfig) Reset() {
	*x = TabConfig{}
	mi := &file_cache_server_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TabConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TabConfig) ProtoMessage() {}

func (x *TabConfig) ProtoReflect() protoreflect.Message {
	mi := &file_cache_server_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TabConfig.ProtoReflect.Descriptor instead.
func (*TabConfig) Descriptor() ([]byte, []int) {
	return file_cache_server_proto_rawDescGZIP(), []int{24}
}

func (x *TabConfig) GetExperimentData() *ExperimentData {
	if x != nil {
		return x.ExperimentData
	}
	return nil
}

func (x *TabConfig) GetConfigData() *RemoteConfigData {
	if x != nil {
		return x.ConfigData
	}
	return nil
}

func (x *TabConfig) GetControlData() *ControlData {
	if x != nil {
		return x.ControlData
	}
	return nil
}

type TabConfigManager struct {
	state     protoimpl.MessageState `protogen:"open.v1"`
	ProjectId string                 `protobuf:"bytes,1,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	Version   string                 `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	// OriginType origin_type = 3;
	UpdateType     UpdateType `protobuf:"varint,4,opt,name=update_type,json=updateType,proto3,enum=opensource.tab.cache_server.UpdateType" json:"update_type,omitempty"`
	TabConfig      *TabConfig `protobuf:"bytes,10,opt,name=tab_config,json=tabConfig,proto3" json:"tab_config,omitempty"`
	TabConfigPatch []byte     `protobuf:"bytes,11,opt,name=tab_config_patch,json=tabConfigPatch,proto3" json:"tab_config_patch,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *TabConfigManager) Reset() {
	*x = TabConfigManager{}
	mi := &file_cache_server_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TabConfigManager) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TabConfigManager) ProtoMessage() {}

func (x *TabConfigManager) ProtoReflect() protoreflect.Message {
	mi := &file_cache_server_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TabConfigManager.ProtoReflect.Descriptor instead.
func (*TabConfigManager) Descriptor() ([]byte, []int) {
	return file_cache_server_proto_rawDescGZIP(), []int{25}
}

func (x *TabConfigManager) GetProjectId() string {
	if x != nil {
		return x.ProjectId
	}
	return ""
}

func (x *TabConfigManager) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *TabConfigManager) GetUpdateType() UpdateType {
	if x != nil {
		return x.UpdateType
	}
	return UpdateType_UPDATE_TYPE_UNKNOWN
}

func (x *TabConfigManager) GetTabConfig() *TabConfig {
	if x != nil {
		return x.TabConfig
	}
	return nil
}

func (x *TabConfigManager) GetTabConfigPatch() []byte {
	if x != nil {
		return x.TabConfigPatch
	}
	return nil
}

type BucketInfo struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	BucketType    BucketType             `protobuf:"varint,1,opt,name=bucket_type,json=bucketType,proto3,enum=opensource.tab.cache_server.BucketType" json:"bucket_type,omitempty"`
	TrafficRange  *TrafficRange          `protobuf:"bytes,2,opt,name=traffic_range,json=trafficRange,proto3" json:"traffic_range,omitempty"`
	Bitmap        []byte                 `protobuf:"bytes,3,opt,name=bitmap,proto3" json:"bitmap,omitempty"`
	Version       string                 `protobuf:"bytes,4,opt,name=version,proto3" json:"version,omitempty"`
	ModifyType    ModifyType             `protobuf:"varint,5,opt,name=modify_type,json=modifyType,proto3,enum=opensource.tab.cache_server.ModifyType" json:"modify_type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BucketInfo) Reset() {
	*x = BucketInfo{}
	mi := &file_cache_server_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BucketInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BucketInfo) ProtoMessage() {}

func (x *BucketInfo) ProtoReflect() protoreflect.Message {
	mi := &file_cache_server_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BucketInfo.ProtoReflect.Descriptor instead.
func (*BucketInfo) Descriptor() ([]byte, []int) {
	return file_cache_server_proto_rawDescGZIP(), []int{26}
}

func (x *BucketInfo) GetBucketType() BucketType {
	if x != nil {
		return x.BucketType
	}
	return BucketType_BUCKET_TYPE_UNKNOWN
}

func (x *BucketInfo) GetTrafficRange() *TrafficRange {
	if x != nil {
		return x.TrafficRange
	}
	return nil
}

func (x *BucketInfo) GetBitmap() []byte {
	if x != nil {
		return x.Bitmap
	}
	return nil
}

func (x *BucketInfo) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *BucketInfo) GetModifyType() ModifyType {
	if x != nil {
		return x.ModifyType
	}
	return ModifyType_MODIFY_UNKNOWN
}

type BatchGetExperimentBucketReq struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	ProjectId          string                 `protobuf:"bytes,1,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	SdkVersion         string                 `protobuf:"bytes,2,opt,name=sdk_version,json=sdkVersion,proto3" json:"sdk_version,omitempty"`
	BucketVersionIndex map[int64]string       `protobuf:"bytes,3,rep,name=bucket_version_index,json=bucketVersionIndex,proto3" json:"bucket_version_index,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *BatchGetExperimentBucketReq) Reset() {
	*x = BatchGetExperimentBucketReq{}
	mi := &file_cache_server_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BatchGetExperimentBucketReq) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BatchGetExperimentBucketReq) ProtoMessage() {}

func (x *BatchGetExperimentBucketReq) ProtoReflect() protoreflect.Message {
	mi := &file_cache_server_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BatchGetExperimentBucketReq.ProtoReflect.Descriptor instead.
func (*BatchGetExperimentBucketReq) Descriptor() ([]byte, []int) {
	return file_cache_server_proto_rawDescGZIP(), []int{27}
}

func (x *BatchGetExperimentBucketReq) GetProjectId() string {
	if x != nil {
		return x.ProjectId
	}
	return ""
}

func (x *BatchGetExperimentBucketReq) GetSdkVersion() string {
	if x != nil {
		return x.SdkVersion
	}
	return ""
}

func (x *BatchGetExperimentBucketReq) GetBucketVersionIndex() map[int64]string {
	if x != nil {
		return x.BucketVersionIndex
	}
	return nil
}

// Get experimental bucket information in batches
type BatchGetExperimentBucketResp struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Code          Code                   `protobuf:"varint,1,opt,name=code,proto3,enum=opensource.tab.cache_server.Code" json:"code,omitempty"`                                                   // error code
	Message       string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`                                                                                    // Detailed description
	BucketIndex   map[int64]*BucketInfo  `protobuf:"bytes,3,rep,name=bucketIndex,proto3" json:"bucketIndex,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // Experiment bucket index, key is the experiment ID, only returns the experiment bucket information with changed version number
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BatchGetExperimentBucketResp) Reset() {
	*x = BatchGetExperimentBucketResp{}
	mi := &file_cache_server_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BatchGetExperimentBucketResp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BatchGetExperimentBucketResp) ProtoMessage() {}

func (x *BatchGetExperimentBucketResp) ProtoReflect() protoreflect.Message {
	mi := &file_cache_server_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BatchGetExperimentBucketResp.ProtoReflect.Descriptor instead.
func (*BatchGetExperimentBucketResp) Descriptor() ([]byte, []int) {
	return file_cache_server_proto_rawDescGZIP(), []int{28}
}

func (x *BatchGetExperimentBucketResp) GetCode() Code {
	if x != nil {
		return x.Code
	}
	return Code_CODE_SUCCESS
}

func (x *BatchGetExperimentBucketResp) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *BatchGetExperimentBucketResp) GetBucketIndex() map[int64]*BucketInfo {
	if x != nil {
		return x.BucketIndex
	}
	return nil
}

// Get experimental group bucket information in batches
type BatchGetGroupBucketReq struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	ProjectId          string                 `protobuf:"bytes,1,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`                                                                                                         // project id
	SdkVersion         string                 `protobuf:"bytes,2,opt,name=sdk_version,json=sdkVersion,proto3" json:"sdk_version,omitempty"`                                                                                                      // sdk version
	BucketVersionIndex map[int64]string       `protobuf:"bytes,3,rep,name=bucket_version_index,json=bucketVersionIndex,proto3" json:"bucket_version_index,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // Experiment group ID and version index, key is the experiment group ID
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *BatchGetGroupBucketReq) Reset() {
	*x = BatchGetGroupBucketReq{}
	mi := &file_cache_server_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BatchGetGroupBucketReq) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BatchGetGroupBucketReq) ProtoMessage() {}

func (x *BatchGetGroupBucketReq) ProtoReflect() protoreflect.Message {
	mi := &file_cache_server_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BatchGetGroupBucketReq.ProtoReflect.Descriptor instead.
func (*BatchGetGroupBucketReq) Descriptor() ([]byte, []int) {
	return file_cache_server_proto_rawDescGZIP(), []int{29}
}

func (x *BatchGetGroupBucketReq) GetProjectId() string {
	if x != nil {
		return x.ProjectId
	}
	return ""
}

func (x *BatchGetGroupBucketReq) GetSdkVersion() string {
	if x != nil {
		return x.SdkVersion
	}
	return ""
}

func (x *BatchGetGroupBucketReq) GetBucketVersionIndex() map[int64]string {
	if x != nil {
		return x.BucketVersionIndex
	}
	return nil
}

// Get experimental group bucket information in batches
type BatchGetGroupBucketResp struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Code          Code                   `protobuf:"varint,1,opt,name=code,proto3,enum=opensource.tab.cache_server.Code" json:"code,omitempty"`                                                   // error code
	Message       string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`                                                                                    // Detailed description
	BucketIndex   map[int64]*BucketInfo  `protobuf:"bytes,3,rep,name=bucketIndex,proto3" json:"bucketIndex,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // Experiment group bucket index, key is the experiment group ID, only returns the experiment bucket information with changed version number
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BatchGetGroupBucketResp) Reset() {
	*x = BatchGetGroupBucketResp{}
	mi := &file_cache_server_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BatchGetGroupBucketResp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BatchGetGroupBucketResp) ProtoMessage() {}

func (x *BatchGetGroupBucketResp) ProtoReflect() protoreflect.Message {
	mi := &file_cache_server_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BatchGetGroupBucketResp.ProtoReflect.Descriptor instead.
func (*BatchGetGroupBucketResp) Descriptor() ([]byte, []int) {
	return file_cache_server_proto_rawDescGZIP(), []int{30}
}

func (x *BatchGetGroupBucketResp) GetCode() Code {
	if x != nil {
		return x.Code
	}
	return Code_CODE_SUCCESS
}

func (x *BatchGetGroupBucketResp) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *BatchGetGroupBucketResp) GetBucketIndex() map[int64]*BucketInfo {
	if x != nil {
		return x.BucketIndex
	}
	return nil
}

var File_cache_server_proto protoreflect.FileDescriptor

const file_cache_server_proto_rawDesc = "" +
	"\n" +
	"\x12cache_server.proto\x12\x1bopensource.tab.cache_server\x1a\x1cgoogle/api/annotations.proto\"\xcd\x01\n" +
	"\x0fGetTabConfigReq\x12\x1d\n" +
	"\n" +
	"project_id\x18\x01 \x01(\tR\tprojectId\x12\x18\n" +
	"\aversion\x18\x02 \x01(\tR\aversion\x12H\n" +
	"\vupdate_type\x18\x04 \x01(\x0e2'.opensource.tab.cache_server.UpdateTypeR\n" +
	"updateType\x12\x1f\n" +
	"\vsdk_version\x18\x05 \x01(\tR\n" +
	"sdkVersion\x12\x16\n" +
	"\x06region\x18\n" +
	" \x01(\tR\x06region\"\xc0\x01\n" +
	"\x10GetTabConfigResp\x125\n" +
	"\x04code\x18\x01 \x01(\x0e2!.opensource.tab.cache_server.CodeR\x04code\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\x12[\n" +
	"\x12tab_config_manager\x18\n" +
	" \x01(\v2-.opensource.tab.cache_server.TabConfigManagerR\x10tabConfigManager\"\xbf\x01\n" +
	"\x0eLayerToGroupID\x12j\n" +
	"\x11layer_to_group_id\x18\x01 \x03(\v2?.opensource.tab.cache_server.LayerToGroupID.LayerToGroupIdEntryR\x0elayerToGroupId\x1aA\n" +
	"\x13LayerToGroupIdEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\x03R\x05value:\x028\x01\"\xd9\x02\n" +
	"\x06Domain\x12G\n" +
	"\bmetadata\x18\x01 \x01(\v2+.opensource.tab.cache_server.DomainMetadataR\bmetadata\x12Z\n" +
	"\x13holdout_domain_list\x18\n" +
	" \x03(\v2*.opensource.tab.cache_server.HoldoutDomainR\x11holdoutDomainList\x12d\n" +
	"\x17multi_layer_domain_list\x18\v \x03(\v2-.opensource.tab.cache_server.MultiLayerDomainR\x14multiLayerDomainList\x12D\n" +
	"\vdomain_list\x18\f \x03(\v2#.opensource.tab.cache_server.DomainR\n" +
	"domainList\"\xd8\x03\n" +
	"\x05Layer\x12F\n" +
	"\bmetadata\x18\x01 \x01(\v2*.opensource.tab.cache_server.LayerMetadataR\bmetadata\x12S\n" +
	"\vgroup_index\x18\n" +
	" \x03(\v22.opensource.tab.cache_server.Layer.GroupIndexEntryR\n" +
	"groupIndex\x12b\n" +
	"\x10experiment_index\x18\v \x03(\v27.opensource.tab.cache_server.Layer.ExperimentIndexEntryR\x0fexperimentIndex\x1aa\n" +
	"\x0fGroupIndexEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x03R\x03key\x128\n" +
	"\x05value\x18\x02 \x01(\v2\".opensource.tab.cache_server.GroupR\x05value:\x028\x01\x1ak\n" +
	"\x14ExperimentIndexEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x03R\x03key\x12=\n" +
	"\x05value\x18\x02 \x01(\v2'.opensource.tab.cache_server.ExperimentR\x05value:\x028\x01\"\x9f\x03\n" +
	"\n" +
	"Experiment\x12H\n" +
	"\vhash_method\x18\x01 \x01(\x0e2'.opensource.tab.cache_server.HashMethodR\n" +
	"hashMethod\x12\x1b\n" +
	"\thash_seed\x18\x02 \x01(\x03R\bhashSeed\x12\x0e\n" +
	"\x02id\x18\x03 \x01(\x03R\x02id\x12\x10\n" +
	"\x03key\x18\x04 \x01(\tR\x03key\x12\x1f\n" +
	"\vbucket_size\x18\x05 \x01(\x03R\n" +
	"bucketSize\x12E\n" +
	"\n" +
	"issue_type\x18\n" +
	" \x01(\x0e2&.opensource.tab.cache_server.IssueTypeR\tissueType\x12_\n" +
	"\x0egroup_id_index\x18\v \x03(\v29.opensource.tab.cache_server.Experiment.GroupIdIndexEntryR\fgroupIdIndex\x1a?\n" +
	"\x11GroupIdIndexEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x03R\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\bR\x05value:\x028\x01\"\x9b\x01\n" +
	"\rHoldoutDomain\x12G\n" +
	"\bmetadata\x18\x01 \x01(\v2+.opensource.tab.cache_server.DomainMetadataR\bmetadata\x12A\n" +
	"\n" +
	"layer_list\x18\n" +
	" \x03(\v2\".opensource.tab.cache_server.LayerR\tlayerList\"\x9e\x01\n" +
	"\x10MultiLayerDomain\x12G\n" +
	"\bmetadata\x18\x01 \x01(\v2+.opensource.tab.cache_server.DomainMetadataR\bmetadata\x12A\n" +
	"\n" +
	"layer_list\x18\n" +
	" \x03(\v2\".opensource.tab.cache_server.LayerR\tlayerList\"\x94\x04\n" +
	"\x05Group\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\x03R\x02id\x12\x1b\n" +
	"\tgroup_key\x18\x02 \x01(\tR\bgroupKey\x12#\n" +
	"\rexperiment_id\x18\x03 \x01(\x03R\fexperimentId\x12%\n" +
	"\x0eexperiment_key\x18\x04 \x01(\tR\rexperimentKey\x12F\n" +
	"\x06params\x18\x05 \x03(\v2..opensource.tab.cache_server.Group.ParamsEntryR\x06params\x12\x1d\n" +
	"\n" +
	"is_default\x18\x06 \x01(\bR\tisDefault\x12\x1d\n" +
	"\n" +
	"is_control\x18\a \x01(\bR\tisControl\x12\x1b\n" +
	"\tlayer_key\x18\b \x01(\tR\blayerKey\x12E\n" +
	"\n" +
	"issue_info\x18\t \x01(\v2&.opensource.tab.cache_server.IssueInfoR\tissueInfo\x12\"\n" +
	"\rscene_id_list\x18\n" +
	" \x03(\x03R\vsceneIdList\x12I\n" +
	"\funit_id_type\x18\v \x01(\x0e2'.opensource.tab.cache_server.UnitIDTypeR\n" +
	"unitIdType\x1a9\n" +
	"\vParamsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x9e\x01\n" +
	"\tIssueInfo\x12E\n" +
	"\n" +
	"issue_type\x18\x01 \x01(\x0e2&.opensource.tab.cache_server.IssueTypeR\tissueType\x12J\n" +
	"\x0etag_list_group\x18\x02 \x03(\v2$.opensource.tab.cache_server.tagListR\ftagListGroup\"F\n" +
	"\atagList\x12;\n" +
	"\btag_list\x18\x02 \x03(\v2 .opensource.tab.cache_server.tagR\atagList\"\xe6\x02\n" +
	"\x03tag\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12?\n" +
	"\btag_type\x18\x02 \x01(\x0e2$.opensource.tab.cache_server.TagTypeR\atagType\x12A\n" +
	"\boperator\x18\x03 \x01(\x0e2%.opensource.tab.cache_server.OperatorR\boperator\x12\x14\n" +
	"\x05value\x18\x04 \x01(\tR\x05value\x12!\n" +
	"\fdmp_platform\x18\x05 \x01(\x03R\vdmpPlatform\x12I\n" +
	"\funit_id_type\x18\x06 \x01(\x0e2'.opensource.tab.cache_server.UnitIDTypeR\n" +
	"unitIdType\x12E\n" +
	"\n" +
	"tag_origin\x18\a \x01(\x0e2&.opensource.tab.cache_server.TagOriginR\ttagOrigin\"\x98\x03\n" +
	"\x0eDomainMetadata\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12H\n" +
	"\vdomain_type\x18\x02 \x01(\x0e2'.opensource.tab.cache_server.DomainTypeR\n" +
	"domainType\x12H\n" +
	"\vhash_method\x18\x03 \x01(\x0e2'.opensource.tab.cache_server.HashMethodR\n" +
	"hashMethod\x12\x1b\n" +
	"\thash_seed\x18\x04 \x01(\x03R\bhashSeed\x12I\n" +
	"\funit_id_type\x18\x05 \x01(\x0e2'.opensource.tab.cache_server.UnitIDTypeR\n" +
	"unitIdType\x12\x1f\n" +
	"\vbucket_size\x18\x06 \x01(\x03R\n" +
	"bucketSize\x12W\n" +
	"\x12traffic_range_list\x18\n" +
	" \x03(\v2).opensource.tab.cache_server.TrafficRangeR\x10trafficRangeList\"\xf3\x04\n" +
	"\rLayerMetadata\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12G\n" +
	"\rdefault_group\x18\x02 \x01(\v2\".opensource.tab.cache_server.GroupR\fdefaultGroup\x12B\n" +
	"\thash_type\x18\x03 \x01(\x0e2%.opensource.tab.cache_server.HashTypeR\bhashType\x12H\n" +
	"\vhash_method\x18\x04 \x01(\x0e2'.opensource.tab.cache_server.HashMethodR\n" +
	"hashMethod\x12\x1b\n" +
	"\thash_seed\x18\x05 \x01(\x03R\bhashSeed\x12\"\n" +
	"\rscene_id_list\x18\x06 \x03(\x03R\vsceneIdList\x12I\n" +
	"\funit_id_type\x18\a \x01(\x0e2'.opensource.tab.cache_server.UnitIDTypeR\n" +
	"unitIdType\x12W\n" +
	"\x12traffic_range_list\x18\b \x03(\v2).opensource.tab.cache_server.TrafficRangeR\x10trafficRangeList\x12\x1f\n" +
	"\vbucket_size\x18\n" +
	" \x01(\x03R\n" +
	"bucketSize\x12,\n" +
	"\x12holdout_layer_keys\x18\v \x03(\tR\x10holdoutLayerKeys\x12E\n" +
	"\n" +
	"layer_type\x18\f \x01(\x0e2&.opensource.tab.cache_server.LayerTypeR\tlayerType\"8\n" +
	"\fTrafficRange\x12\x12\n" +
	"\x04left\x18\x01 \x01(\x03R\x04left\x12\x14\n" +
	"\x05right\x18\x02 \x01(\x03R\x05right\"\xa3\x03\n" +
	"\x0eExperimentData\x12(\n" +
	"\x10default_group_id\x18\x01 \x01(\x03R\x0edefaultGroupId\x12b\n" +
	"\roverride_list\x18\x02 \x03(\v2=.opensource.tab.cache_server.ExperimentData.OverrideListEntryR\foverrideList\x12H\n" +
	"\rglobal_domain\x18\x03 \x01(\v2#.opensource.tab.cache_server.DomainR\fglobalDomain\x12K\n" +
	"\fholdout_data\x18\x04 \x01(\v2(.opensource.tab.cache_server.HoldoutDataR\vholdoutData\x1al\n" +
	"\x11OverrideListEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12A\n" +
	"\x05value\x18\x02 \x01(\v2+.opensource.tab.cache_server.LayerToGroupIDR\x05value:\x028\x01\"\xe8\x01\n" +
	"\vHoldoutData\x12o\n" +
	"\x13holdout_layer_index\x18\x01 \x03(\v2?.opensource.tab.cache_server.HoldoutData.HoldoutLayerIndexEntryR\x11holdoutLayerIndex\x1ah\n" +
	"\x16HoldoutLayerIndexEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x128\n" +
	"\x05value\x18\x02 \x01(\v2\".opensource.tab.cache_server.LayerR\x05value:\x028\x01\"\xf9\x01\n" +
	"\x10RemoteConfigData\x12t\n" +
	"\x13remote_config_index\x18\x01 \x03(\v2D.opensource.tab.cache_server.RemoteConfigData.RemoteConfigIndexEntryR\x11remoteConfigIndex\x1ao\n" +
	"\x16RemoteConfigIndexEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12?\n" +
	"\x05value\x18\x02 \x01(\v2).opensource.tab.cache_server.RemoteConfigR\x05value:\x028\x01\"\xeb\x03\n" +
	"\fRemoteConfig\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12#\n" +
	"\rdefault_value\x18\x02 \x01(\fR\fdefaultValue\x12\x18\n" +
	"\aversion\x18\x03 \x01(\tR\aversion\x12\"\n" +
	"\rscene_id_list\x18\x04 \x03(\x03R\vsceneIdList\x12F\n" +
	"\x04type\x18\x05 \x01(\x0e22.opensource.tab.cache_server.RemoteConfigValueTypeR\x04type\x12M\n" +
	"\x0econdition_list\x18\x06 \x03(\v2&.opensource.tab.cache_server.ConditionR\rconditionList\x12`\n" +
	"\roverride_list\x18\n" +
	" \x03(\v2;.opensource.tab.cache_server.RemoteConfig.OverrideListEntryR\foverrideList\x12,\n" +
	"\x12holdout_layer_keys\x18\v \x03(\tR\x10holdoutLayerKeys\x1a?\n" +
	"\x11OverrideListEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\fR\x05value:\x028\x01\"\xed\x03\n" +
	"\tCondition\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\x03R\x02id\x12\x10\n" +
	"\x03key\x18\x02 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x03 \x01(\fR\x05value\x12H\n" +
	"\vhash_method\x18\x04 \x01(\x0e2'.opensource.tab.cache_server.HashMethodR\n" +
	"hashMethod\x12\x1b\n" +
	"\thash_seed\x18\x05 \x01(\x03R\bhashSeed\x12%\n" +
	"\x0eexperiment_key\x18\x06 \x01(\tR\rexperimentKey\x12\x1f\n" +
	"\vbucket_size\x18\a \x01(\x03R\n" +
	"bucketSize\x12H\n" +
	"\vbucket_info\x18\b \x01(\v2'.opensource.tab.cache_server.BucketInfoR\n" +
	"bucketInfo\x12I\n" +
	"\funit_id_type\x18\t \x01(\x0e2'.opensource.tab.cache_server.UnitIDTypeR\n" +
	"unitIdType\x12E\n" +
	"\n" +
	"issue_info\x18\n" +
	" \x01(\v2&.opensource.tab.cache_server.IssueInfoR\tissueInfo\x12\x1d\n" +
	"\n" +
	"config_key\x18\v \x01(\tR\tconfigKey\"\xc1\r\n" +
	"\vControlData\x12)\n" +
	"\x10refresh_interval\x18\x01 \x01(\rR\x0frefreshInterval\x12v\n" +
	"\x16ignore_report_group_id\x18\x02 \x03(\v2A.opensource.tab.cache_server.ControlData.IgnoreReportGroupIdEntryR\x13ignoreReportGroupId\x12\x81\x01\n" +
	"\x19experiment_metrics_config\x18\x03 \x03(\v2E.opensource.tab.cache_server.ControlData.ExperimentMetricsConfigEntryR\x17experimentMetricsConfig\x12u\n" +
	"!default_experiment_metrics_config\x18\x04 \x01(\v2*.opensource.tab.cache_server.MetricsConfigR\x1edefaultExperimentMetricsConfig\x12\x88\x01\n" +
	"\x1cremote_config_metrics_config\x18\x05 \x03(\v2G.opensource.tab.cache_server.ControlData.RemoteConfigMetricsConfigEntryR\x19remoteConfigMetricsConfig\x12z\n" +
	"$default_remote_config_metrics_config\x18\x06 \x01(\v2*.opensource.tab.cache_server.MetricsConfigR defaultRemoteConfigMetricsConfig\x12\x85\x01\n" +
	"\x1bfeature_flag_metrics_config\x18\a \x03(\v2F.opensource.tab.cache_server.ControlData.FeatureFlagMetricsConfigEntryR\x18featureFlagMetricsConfig\x12x\n" +
	"#default_feature_flag_metrics_config\x18\b \x01(\v2*.opensource.tab.cache_server.MetricsConfigR\x1fdefaultFeatureFlagMetricsConfig\x12\\\n" +
	"\x14event_metrics_config\x18\t \x01(\v2*.opensource.tab.cache_server.MetricsConfigR\x12eventMetricsConfig\x12\x7f\n" +
	"\x19metrics_init_config_index\x18\n" +
	" \x03(\v2D.opensource.tab.cache_server.ControlData.MetricsInitConfigIndexEntryR\x16metricsInitConfigIndex\x1aF\n" +
	"\x18IgnoreReportGroupIdEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x03R\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\bR\x05value:\x028\x01\x1av\n" +
	"\x1cExperimentMetricsConfigEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x03R\x03key\x12@\n" +
	"\x05value\x18\x02 \x01(\v2*.opensource.tab.cache_server.MetricsConfigR\x05value:\x028\x01\x1ax\n" +
	"\x1eRemoteConfigMetricsConfigEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x03R\x03key\x12@\n" +
	"\x05value\x18\x02 \x01(\v2*.opensource.tab.cache_server.MetricsConfigR\x05value:\x028\x01\x1aw\n" +
	"\x1dFeatureFlagMetricsConfigEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x03R\x03key\x12@\n" +
	"\x05value\x18\x02 \x01(\v2*.opensource.tab.cache_server.MetricsConfigR\x05value:\x028\x01\x1ay\n" +
	"\x1bMetricsInitConfigIndexEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12D\n" +
	"\x05value\x18\x02 \x01(\v2..opensource.tab.cache_server.MetricsInitConfigR\x05value:\x028\x01\"\xb6\x02\n" +
	"\rMetricsConfig\x12!\n" +
	"\fis_automatic\x18\x01 \x01(\bR\visAutomatic\x12\x1b\n" +
	"\tis_enable\x18\x02 \x01(\bR\bisEnable\x12\x1f\n" +
	"\vplugin_name\x18\x03 \x01(\tR\n" +
	"pluginName\x12\x19\n" +
	"\bscene_id\x18\x04 \x01(\x03R\asceneId\x12+\n" +
	"\x11sampling_interval\x18\x05 \x01(\rR\x10samplingInterval\x122\n" +
	"\x15err_sampling_interval\x18\x06 \x01(\rR\x13errSamplingInterval\x12H\n" +
	"\bmetadata\x18\n" +
	" \x01(\v2,.opensource.tab.cache_server.MetricsMetadataR\bmetadata\"\xbe\x01\n" +
	"\x11MetricsInitConfig\x12\x16\n" +
	"\x06Region\x18\x01 \x01(\tR\x06Region\x12\x12\n" +
	"\x04addr\x18\x02 \x01(\tR\x04addr\x12F\n" +
	"\x02kv\x18\x03 \x03(\v26.opensource.tab.cache_server.MetricsInitConfig.KvEntryR\x02kv\x1a5\n" +
	"\aKvEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xf1\x01\n" +
	"\x0fMetricsMetadata\x12c\n" +
	"\rexpanded_data\x18\x01 \x03(\v2>.opensource.tab.cache_server.MetricsMetadata.ExpandedDataEntryR\fexpandedData\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12\x0e\n" +
	"\x02id\x18\x03 \x01(\tR\x02id\x12\x14\n" +
	"\x05token\x18\x04 \x01(\tR\x05token\x1a?\n" +
	"\x11ExpandedDataEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xfe\x01\n" +
	"\tTabConfig\x12T\n" +
	"\x0fexperiment_data\x18\x01 \x01(\v2+.opensource.tab.cache_server.ExperimentDataR\x0eexperimentData\x12N\n" +
	"\vconfig_data\x18\x02 \x01(\v2-.opensource.tab.cache_server.RemoteConfigDataR\n" +
	"configData\x12K\n" +
	"\fcontrol_data\x18\x03 \x01(\v2(.opensource.tab.cache_server.ControlDataR\vcontrolData\"\x86\x02\n" +
	"\x10TabConfigManager\x12\x1d\n" +
	"\n" +
	"project_id\x18\x01 \x01(\tR\tprojectId\x12\x18\n" +
	"\aversion\x18\x02 \x01(\tR\aversion\x12H\n" +
	"\vupdate_type\x18\x04 \x01(\x0e2'.opensource.tab.cache_server.UpdateTypeR\n" +
	"updateType\x12E\n" +
	"\n" +
	"tab_config\x18\n" +
	" \x01(\v2&.opensource.tab.cache_server.TabConfigR\ttabConfig\x12(\n" +
	"\x10tab_config_patch\x18\v \x01(\fR\x0etabConfigPatch\"\xa2\x02\n" +
	"\n" +
	"BucketInfo\x12H\n" +
	"\vbucket_type\x18\x01 \x01(\x0e2'.opensource.tab.cache_server.BucketTypeR\n" +
	"bucketType\x12N\n" +
	"\rtraffic_range\x18\x02 \x01(\v2).opensource.tab.cache_server.TrafficRangeR\ftrafficRange\x12\x16\n" +
	"\x06bitmap\x18\x03 \x01(\fR\x06bitmap\x12\x18\n" +
	"\aversion\x18\x04 \x01(\tR\aversion\x12H\n" +
	"\vmodify_type\x18\x05 \x01(\x0e2'.opensource.tab.cache_server.ModifyTypeR\n" +
	"modifyType\"\xa9\x02\n" +
	"\x1bBatchGetExperimentBucketReq\x12\x1d\n" +
	"\n" +
	"project_id\x18\x01 \x01(\tR\tprojectId\x12\x1f\n" +
	"\vsdk_version\x18\x02 \x01(\tR\n" +
	"sdkVersion\x12\x82\x01\n" +
	"\x14bucket_version_index\x18\x03 \x03(\v2P.opensource.tab.cache_server.BatchGetExperimentBucketReq.BucketVersionIndexEntryR\x12bucketVersionIndex\x1aE\n" +
	"\x17BucketVersionIndexEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x03R\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xc6\x02\n" +
	"\x1cBatchGetExperimentBucketResp\x125\n" +
	"\x04code\x18\x01 \x01(\x0e2!.opensource.tab.cache_server.CodeR\x04code\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\x12l\n" +
	"\vbucketIndex\x18\x03 \x03(\v2J.opensource.tab.cache_server.BatchGetExperimentBucketResp.BucketIndexEntryR\vbucketIndex\x1ag\n" +
	"\x10BucketIndexEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x03R\x03key\x12=\n" +
	"\x05value\x18\x02 \x01(\v2'.opensource.tab.cache_server.BucketInfoR\x05value:\x028\x01\"\x9e\x02\n" +
	"\x16BatchGetGroupBucketReq\x12\x1d\n" +
	"\n" +
	"project_id\x18\x01 \x01(\tR\tprojectId\x12\x1f\n" +
	"\vsdk_version\x18\x02 \x01(\tR\n" +
	"sdkVersion\x12}\n" +
	"\x14bucket_version_index\x18\x03 \x03(\v2K.opensource.tab.cache_server.BatchGetGroupBucketReq.BucketVersionIndexEntryR\x12bucketVersionIndex\x1aE\n" +
	"\x17BucketVersionIndexEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x03R\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xbc\x02\n" +
	"\x17BatchGetGroupBucketResp\x125\n" +
	"\x04code\x18\x01 \x01(\x0e2!.opensource.tab.cache_server.CodeR\x04code\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\x12g\n" +
	"\vbucketIndex\x18\x03 \x03(\v2E.opensource.tab.cache_server.BatchGetGroupBucketResp.BucketIndexEntryR\vbucketIndex\x1ag\n" +
	"\x10BucketIndexEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x03R\x03key\x12=\n" +
	"\x05value\x18\x02 \x01(\v2'.opensource.tab.cache_server.BucketInfoR\x05value:\x028\x01*U\n" +
	"\n" +
	"OriginType\x12\x17\n" +
	"\x13ORIGIN_TYPE_UNKNOWN\x10\x00\x12\x16\n" +
	"\x12ORIGIN_TYPE_SERVER\x10\x01\x12\x16\n" +
	"\x12ORIGIN_TYPE_MOBILE\x10\x02*T\n" +
	"\n" +
	"UpdateType\x12\x17\n" +
	"\x13UPDATE_TYPE_UNKNOWN\x10\x00\x12\x18\n" +
	"\x14UPDATE_TYPE_COMPLETE\x10\x01\x12\x13\n" +
	"\x0fUPDATE_YPE_DIFF\x10\x02*\xaf\x01\n" +
	"\x04Code\x12\x10\n" +
	"\fCODE_SUCCESS\x10\x00\x12\x17\n" +
	"\x12CODE_NO_PERMISSION\x10\xe9\a\x12\x17\n" +
	"\x12CODE_TRAFFIC_LIMIT\x10\xea\a\x12\x1c\n" +
	"\x17CODE_INVALID_PROJECT_ID\x10\xeb\a\x12\x14\n" +
	"\x0fCODE_SERVER_ERR\x10\xec\a\x12\x17\n" +
	"\x12CODE_INVALID_PARAM\x10\xed\a\x12\x16\n" +
	"\x11CODE_SAME_VERSION\x10\xd1\x0f*\xab\x01\n" +
	"\n" +
	"HashMethod\x12\x17\n" +
	"\x13HASH_METHOD_UNKNOWN\x10\x00\x12\x14\n" +
	"\x10HASH_METHOD_BKDR\x10\x01\x12\x17\n" +
	"\x13HASH_METHOD_MURMUR3\x10\x02\x12\x13\n" +
	"\x0fHASH_METHOD_DJB\x10\x03\x12\x13\n" +
	"\x0fHASH_METHOD_NEW\x10\x04\x12\x17\n" +
	"\x13HASH_METHOD_NEW_MD5\x10\x05\x12\x12\n" +
	"\x0eHASH_METHOD_AP\x10\x06*M\n" +
	"\bHashType\x12\x15\n" +
	"\x11HASH_TYPE_UNKNOWN\x10\x00\x12\x14\n" +
	"\x10HASH_TYPE_SINGLE\x10\x01\x12\x14\n" +
	"\x10HASH_TYPE_DOUBLE\x10\x02*K\n" +
	"\tTagOrigin\x12\x16\n" +
	"\x12TAG_ORIGIN_UNKNOWN\x10\x00\x12\x12\n" +
	"\x0eTAG_ORIGIN_TAG\x10\x01\x12\x12\n" +
	"\x0eTAG_ORIGIN_DMP\x10\x02*\xbb\x03\n" +
	"\bOperator\x12\x14\n" +
	"\x10OPERATOR_UNKNOWN\x10\x00\x12\x0f\n" +
	"\vOPERATOR_EQ\x10\x01\x12\x0f\n" +
	"\vOPERATOR_LT\x10\x02\x12\x10\n" +
	"\fOPERATOR_LTE\x10\x03\x12\x0f\n" +
	"\vOPERATOR_GT\x10\x04\x12\x10\n" +
	"\fOPERATOR_GTE\x10\x05\x12\x0f\n" +
	"\vOPERATOR_NE\x10\x06\x12\x14\n" +
	"\x10OPERATOR_REGULAR\x10\a\x12\x0f\n" +
	"\vOPERATOR_IN\x10\b\x12\x13\n" +
	"\x0fOPERATOR_NOT_IN\x10\t\x12\x16\n" +
	"\x12OPERATOR_SUPER_SET\x10\n" +
	"\x12\x14\n" +
	"\x10OPERATOR_SUB_SET\x10\v\x12\x11\n" +
	"\rOPERATOR_TRUE\x10\f\x12\x12\n" +
	"\x0eOPERATOR_FALSE\x10\r\x12\x11\n" +
	"\rOPERATOR_LORO\x10\x0e\x12\x11\n" +
	"\rOPERATOR_LORC\x10\x0f\x12\x11\n" +
	"\rOPERATOR_LCRO\x10\x10\x12\x11\n" +
	"\rOPERATOR_LCRC\x10\x11\x12\x12\n" +
	"\x0eOPERATOR_EMPTY\x10\x12\x12\x16\n" +
	"\x12OPERATOR_NOT_EMPTY\x10\x13\x12\x11\n" +
	"\rOPERATOR_LIKE\x10\x14\x12\x15\n" +
	"\x11OPERATOR_NOT_LIKE\x10\x15*\xad\x01\n" +
	"\aTagType\x12\x14\n" +
	"\x10TAG_TYPE_UNKNOWN\x10\x00\x12\x13\n" +
	"\x0fTAG_TYPE_STRING\x10\x01\x12\x13\n" +
	"\x0fTAG_TYPE_NUMBER\x10\x02\x12\x10\n" +
	"\fTAG_TYPE_SET\x10\x03\x12\x14\n" +
	"\x10TAG_TYPE_BOOLEAN\x10\x04\x12\x10\n" +
	"\fTAG_TYPE_DMP\x10\x05\x12\x14\n" +
	"\x10TAG_TYPE_VERSION\x10\x06\x12\x12\n" +
	"\x0eTAG_TYPE_EMPTY\x10\a*k\n" +
	"\tIssueType\x12\x16\n" +
	"\x12ISSUE_TYPE_UNKNOWN\x10\x00\x12\x19\n" +
	"\x15ISSUE_TYPE_PERCENTAGE\x10\x01\x12\x12\n" +
	"\x0eISSUE_TYPE_TAG\x10\x02\x12\x17\n" +
	"\x13ISSUE_TYPE_CITY_TAG\x10\x03*r\n" +
	"\n" +
	"DomainType\x12\x17\n" +
	"\x13DOMAIN_TYPE_UNKNOWN\x10\x00\x12\x16\n" +
	"\x12DOMAIN_TYPE_DOMAIN\x10\x01\x12\x17\n" +
	"\x13DOMAIN_TYPE_HOLDOUT\x10\x02\x12\x1a\n" +
	"\x16DOMAIN_TYPE_MULTILAYER\x10\x03*Y\n" +
	"\n" +
	"UnitIDType\x12\x18\n" +
	"\x14UNIT_ID_TYPE_UNKNOWN\x10\x00\x12\x18\n" +
	"\x14UNIT_ID_TYPE_DEFAULT\x10\x01\x12\x17\n" +
	"\x13UNIT_ID_TYPE_NEW_ID\x10\x02*n\n" +
	"\tLayerType\x12\x18\n" +
	"\x14LAYER_ORIGIN_UNKNOWN\x10\x00\x12\x14\n" +
	"\x10LAYER_ORIGIN_EXP\x10\x01\x12\x17\n" +
	"\x13LAYER_ORIGIN_CONFIG\x10\x02\x12\x18\n" +
	"\x14LAYER_ORIGIN_HOLDOUT\x10\x03*\xa6\x01\n" +
	"\x15RemoteConfigValueType\x12$\n" +
	" REMOTE_CONFIG_VALUE_TYPE_UNKNOWN\x10\x00\x12!\n" +
	"\x1dREMOTE_CONFIG_VALUE_TYPE_BOOL\x10\x01\x12\"\n" +
	"\x1eREMOTE_CONFIG_VALUE_TYPE_BYTES\x10\x02\x12 \n" +
	"\x1cREMOTE_CONFIG_VALUE_TYPE_URL\x10\x03*T\n" +
	"\n" +
	"BucketType\x12\x17\n" +
	"\x13BUCKET_TYPE_UNKNOWN\x10\x00\x12\x16\n" +
	"\x12BUCKET_TYPE_BITMAP\x10\x01\x12\x15\n" +
	"\x11BUCKET_TYPE_RANGE\x10\x02*F\n" +
	"\n" +
	"ModifyType\x12\x12\n" +
	"\x0eMODIFY_UNKNOWN\x10\x00\x12\x11\n" +
	"\rMODIFY_UPDATE\x10\x01\x12\x11\n" +
	"\rMODIFY_DELETE\x10\x022\x8d\x03\n" +
	"\tAPIServer\x12k\n" +
	"\fGetTabConfig\x12,.opensource.tab.cache_server.GetTabConfigReq\x1a-.opensource.tab.cache_server.GetTabConfigResp\x12\x8f\x01\n" +
	"\x18BatchGetExperimentBucket\x128.opensource.tab.cache_server.BatchGetExperimentBucketReq\x1a9.opensource.tab.cache_server.BatchGetExperimentBucketResp\x12\x80\x01\n" +
	"\x13BatchGetGroupBucket\x123.opensource.tab.cache_server.BatchGetGroupBucketReq\x1a4.opensource.tab.cache_server.BatchGetGroupBucketRespB.Z,github.com/abetterchoice/protoc_cache_serverb\x06proto3"

var (
	file_cache_server_proto_rawDescOnce sync.Once
	file_cache_server_proto_rawDescData []byte
)

func file_cache_server_proto_rawDescGZIP() []byte {
	file_cache_server_proto_rawDescOnce.Do(func() {
		file_cache_server_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_cache_server_proto_rawDesc), len(file_cache_server_proto_rawDesc)))
	})
	return file_cache_server_proto_rawDescData
}

var file_cache_server_proto_enumTypes = make([]protoimpl.EnumInfo, 15)
var file_cache_server_proto_msgTypes = make([]protoimpl.MessageInfo, 51)
var file_cache_server_proto_goTypes = []any{
	(OriginType)(0),                      // 0: opensource.tab.cache_server.OriginType
	(UpdateType)(0),                      // 1: opensource.tab.cache_server.UpdateType
	(Code)(0),                            // 2: opensource.tab.cache_server.Code
	(HashMethod)(0),                      // 3: opensource.tab.cache_server.HashMethod
	(HashType)(0),                        // 4: opensource.tab.cache_server.HashType
	(TagOrigin)(0),                       // 5: opensource.tab.cache_server.TagOrigin
	(Operator)(0),                        // 6: opensource.tab.cache_server.Operator
	(TagType)(0),                         // 7: opensource.tab.cache_server.TagType
	(IssueType)(0),                       // 8: opensource.tab.cache_server.IssueType
	(DomainType)(0),                      // 9: opensource.tab.cache_server.DomainType
	(UnitIDType)(0),                      // 10: opensource.tab.cache_server.UnitIDType
	(LayerType)(0),                       // 11: opensource.tab.cache_server.LayerType
	(RemoteConfigValueType)(0),           // 12: opensource.tab.cache_server.RemoteConfigValueType
	(BucketType)(0),                      // 13: opensource.tab.cache_server.BucketType
	(ModifyType)(0),                      // 14: opensource.tab.cache_server.ModifyType
	(*GetTabConfigReq)(nil),              // 15: opensource.tab.cache_server.GetTabConfigReq
	(*GetTabConfigResp)(nil),             // 16: opensource.tab.cache_server.GetTabConfigResp
	(*LayerToGroupID)(nil),               // 17: opensource.tab.cache_server.LayerToGroupID
	(*Domain)(nil),                       // 18: opensource.tab.cache_server.Domain
	(*Layer)(nil),                        // 19: opensource.tab.cache_server.Layer
	(*Experiment)(nil),                   // 20: opensource.tab.cache_server.Experiment
	(*HoldoutDomain)(nil),                // 21: opensource.tab.cache_server.HoldoutDomain
	(*MultiLayerDomain)(nil),             // 22: opensource.tab.cache_server.MultiLayerDomain
	(*Group)(nil),                        // 23: opensource.tab.cache_server.Group
	(*IssueInfo)(nil),                    // 24: opensource.tab.cache_server.IssueInfo
	(*TagList)(nil),                      // 25: opensource.tab.cache_server.tagList
	(*Tag)(nil),                          // 26: opensource.tab.cache_server.tag
	(*DomainMetadata)(nil),               // 27: opensource.tab.cache_server.DomainMetadata
	(*LayerMetadata)(nil),                // 28: opensource.tab.cache_server.LayerMetadata
	(*TrafficRange)(nil),                 // 29: opensource.tab.cache_server.TrafficRange
	(*ExperimentData)(nil),               // 30: opensource.tab.cache_server.ExperimentData
	(*HoldoutData)(nil),                  // 31: opensource.tab.cache_server.HoldoutData
	(*RemoteConfigData)(nil),             // 32: opensource.tab.cache_server.RemoteConfigData
	(*RemoteConfig)(nil),                 // 33: opensource.tab.cache_server.RemoteConfig
	(*Condition)(nil),                    // 34: opensource.tab.cache_server.Condition
	(*ControlData)(nil),                  // 35: opensource.tab.cache_server.ControlData
	(*MetricsConfig)(nil),                // 36: opensource.tab.cache_server.MetricsConfig
	(*MetricsInitConfig)(nil),            // 37: opensource.tab.cache_server.MetricsInitConfig
	(*MetricsMetadata)(nil),              // 38: opensource.tab.cache_server.MetricsMetadata
	(*TabConfig)(nil),                    // 39: opensource.tab.cache_server.TabConfig
	(*TabConfigManager)(nil),             // 40: opensource.tab.cache_server.TabConfigManager
	(*BucketInfo)(nil),                   // 41: opensource.tab.cache_server.BucketInfo
	(*BatchGetExperimentBucketReq)(nil),  // 42: opensource.tab.cache_server.BatchGetExperimentBucketReq
	(*BatchGetExperimentBucketResp)(nil), // 43: opensource.tab.cache_server.BatchGetExperimentBucketResp
	(*BatchGetGroupBucketReq)(nil),       // 44: opensource.tab.cache_server.BatchGetGroupBucketReq
	(*BatchGetGroupBucketResp)(nil),      // 45: opensource.tab.cache_server.BatchGetGroupBucketResp
	nil,                                  // 46: opensource.tab.cache_server.LayerToGroupID.LayerToGroupIdEntry
	nil,                                  // 47: opensource.tab.cache_server.Layer.GroupIndexEntry
	nil,                                  // 48: opensource.tab.cache_server.Layer.ExperimentIndexEntry
	nil,                                  // 49: opensource.tab.cache_server.Experiment.GroupIdIndexEntry
	nil,                                  // 50: opensource.tab.cache_server.Group.ParamsEntry
	nil,                                  // 51: opensource.tab.cache_server.ExperimentData.OverrideListEntry
	nil,                                  // 52: opensource.tab.cache_server.HoldoutData.HoldoutLayerIndexEntry
	nil,                                  // 53: opensource.tab.cache_server.RemoteConfigData.RemoteConfigIndexEntry
	nil,                                  // 54: opensource.tab.cache_server.RemoteConfig.OverrideListEntry
	nil,                                  // 55: opensource.tab.cache_server.ControlData.IgnoreReportGroupIdEntry
	nil,                                  // 56: opensource.tab.cache_server.ControlData.ExperimentMetricsConfigEntry
	nil,                                  // 57: opensource.tab.cache_server.ControlData.RemoteConfigMetricsConfigEntry
	nil,                                  // 58: opensource.tab.cache_server.ControlData.FeatureFlagMetricsConfigEntry
	nil,                                  // 59: opensource.tab.cache_server.ControlData.MetricsInitConfigIndexEntry
	nil,                                  // 60: opensource.tab.cache_server.MetricsInitConfig.KvEntry
	nil,                                  // 61: opensource.tab.cache_server.MetricsMetadata.ExpandedDataEntry
	nil,                                  // 62: opensource.tab.cache_server.BatchGetExperimentBucketReq.BucketVersionIndexEntry
	nil,                                  // 63: opensource.tab.cache_server.BatchGetExperimentBucketResp.BucketIndexEntry
	nil,                                  // 64: opensource.tab.cache_server.BatchGetGroupBucketReq.BucketVersionIndexEntry
	nil,                                  // 65: opensource.tab.cache_server.BatchGetGroupBucketResp.BucketIndexEntry
}
var file_cache_server_proto_depIdxs = []int32{
	1,  // 0: opensource.tab.cache_server.GetTabConfigReq.update_type:type_name -> opensource.tab.cache_server.UpdateType
	2,  // 1: opensource.tab.cache_server.GetTabConfigResp.code:type_name -> opensource.tab.cache_server.Code
	40, // 2: opensource.tab.cache_server.GetTabConfigResp.tab_config_manager:type_name -> opensource.tab.cache_server.TabConfigManager
	46, // 3: opensource.tab.cache_server.LayerToGroupID.layer_to_group_id:type_name -> opensource.tab.cache_server.LayerToGroupID.LayerToGroupIdEntry
	27, // 4: opensource.tab.cache_server.Domain.metadata:type_name -> opensource.tab.cache_server.DomainMetadata
	21, // 5: opensource.tab.cache_server.Domain.holdout_domain_list:type_name -> opensource.tab.cache_server.HoldoutDomain
	22, // 6: opensource.tab.cache_server.Domain.multi_layer_domain_list:type_name -> opensource.tab.cache_server.MultiLayerDomain
	18, // 7: opensource.tab.cache_server.Domain.domain_list:type_name -> opensource.tab.cache_server.Domain
	28, // 8: opensource.tab.cache_server.Layer.metadata:type_name -> opensource.tab.cache_server.LayerMetadata
	47, // 9: opensource.tab.cache_server.Layer.group_index:type_name -> opensource.tab.cache_server.Layer.GroupIndexEntry
	48, // 10: opensource.tab.cache_server.Layer.experiment_index:type_name -> opensource.tab.cache_server.Layer.ExperimentIndexEntry
	3,  // 11: opensource.tab.cache_server.Experiment.hash_method:type_name -> opensource.tab.cache_server.HashMethod
	8,  // 12: opensource.tab.cache_server.Experiment.issue_type:type_name -> opensource.tab.cache_server.IssueType
	49, // 13: opensource.tab.cache_server.Experiment.group_id_index:type_name -> opensource.tab.cache_server.Experiment.GroupIdIndexEntry
	27, // 14: opensource.tab.cache_server.HoldoutDomain.metadata:type_name -> opensource.tab.cache_server.DomainMetadata
	19, // 15: opensource.tab.cache_server.HoldoutDomain.layer_list:type_name -> opensource.tab.cache_server.Layer
	27, // 16: opensource.tab.cache_server.MultiLayerDomain.metadata:type_name -> opensource.tab.cache_server.DomainMetadata
	19, // 17: opensource.tab.cache_server.MultiLayerDomain.layer_list:type_name -> opensource.tab.cache_server.Layer
	50, // 18: opensource.tab.cache_server.Group.params:type_name -> opensource.tab.cache_server.Group.ParamsEntry
	24, // 19: opensource.tab.cache_server.Group.issue_info:type_name -> opensource.tab.cache_server.IssueInfo
	10, // 20: opensource.tab.cache_server.Group.unit_id_type:type_name -> opensource.tab.cache_server.UnitIDType
	8,  // 21: opensource.tab.cache_server.IssueInfo.issue_type:type_name -> opensource.tab.cache_server.IssueType
	25, // 22: opensource.tab.cache_server.IssueInfo.tag_list_group:type_name -> opensource.tab.cache_server.tagList
	26, // 23: opensource.tab.cache_server.tagList.tag_list:type_name -> opensource.tab.cache_server.tag
	7,  // 24: opensource.tab.cache_server.tag.tag_type:type_name -> opensource.tab.cache_server.TagType
	6,  // 25: opensource.tab.cache_server.tag.operator:type_name -> opensource.tab.cache_server.Operator
	10, // 26: opensource.tab.cache_server.tag.unit_id_type:type_name -> opensource.tab.cache_server.UnitIDType
	5,  // 27: opensource.tab.cache_server.tag.tag_origin:type_name -> opensource.tab.cache_server.TagOrigin
	9,  // 28: opensource.tab.cache_server.DomainMetadata.domain_type:type_name -> opensource.tab.cache_server.DomainType
	3,  // 29: opensource.tab.cache_server.DomainMetadata.hash_method:type_name -> opensource.tab.cache_server.HashMethod
	10, // 30: opensource.tab.cache_server.DomainMetadata.unit_id_type:type_name -> opensource.tab.cache_server.UnitIDType
	29, // 31: opensource.tab.cache_server.DomainMetadata.traffic_range_list:type_name -> opensource.tab.cache_server.TrafficRange
	23, // 32: opensource.tab.cache_server.LayerMetadata.default_group:type_name -> opensource.tab.cache_server.Group
	4,  // 33: opensource.tab.cache_server.LayerMetadata.hash_type:type_name -> opensource.tab.cache_server.HashType
	3,  // 34: opensource.tab.cache_server.LayerMetadata.hash_method:type_name -> opensource.tab.cache_server.HashMethod
	10, // 35: opensource.tab.cache_server.LayerMetadata.unit_id_type:type_name -> opensource.tab.cache_server.UnitIDType
	29, // 36: opensource.tab.cache_server.LayerMetadata.traffic_range_list:type_name -> opensource.tab.cache_server.TrafficRange
	11, // 37: opensource.tab.cache_server.LayerMetadata.layer_type:type_name -> opensource.tab.cache_server.LayerType
	51, // 38: opensource.tab.cache_server.ExperimentData.override_list:type_name -> opensource.tab.cache_server.ExperimentData.OverrideListEntry
	18, // 39: opensource.tab.cache_server.ExperimentData.global_domain:type_name -> opensource.tab.cache_server.Domain
	31, // 40: opensource.tab.cache_server.ExperimentData.holdout_data:type_name -> opensource.tab.cache_server.HoldoutData
	52, // 41: opensource.tab.cache_server.HoldoutData.holdout_layer_index:type_name -> opensource.tab.cache_server.HoldoutData.HoldoutLayerIndexEntry
	53, // 42: opensource.tab.cache_server.RemoteConfigData.remote_config_index:type_name -> opensource.tab.cache_server.RemoteConfigData.RemoteConfigIndexEntry
	12, // 43: opensource.tab.cache_server.RemoteConfig.type:type_name -> opensource.tab.cache_server.RemoteConfigValueType
	34, // 44: opensource.tab.cache_server.RemoteConfig.condition_list:type_name -> opensource.tab.cache_server.Condition
	54, // 45: opensource.tab.cache_server.RemoteConfig.override_list:type_name -> opensource.tab.cache_server.RemoteConfig.OverrideListEntry
	3,  // 46: opensource.tab.cache_server.Condition.hash_method:type_name -> opensource.tab.cache_server.HashMethod
	41, // 47: opensource.tab.cache_server.Condition.bucket_info:type_name -> opensource.tab.cache_server.BucketInfo
	10, // 48: opensource.tab.cache_server.Condition.unit_id_type:type_name -> opensource.tab.cache_server.UnitIDType
	24, // 49: opensource.tab.cache_server.Condition.issue_info:type_name -> opensource.tab.cache_server.IssueInfo
	55, // 50: opensource.tab.cache_server.ControlData.ignore_report_group_id:type_name -> opensource.tab.cache_server.ControlData.IgnoreReportGroupIdEntry
	56, // 51: opensource.tab.cache_server.ControlData.experiment_metrics_config:type_name -> opensource.tab.cache_server.ControlData.ExperimentMetricsConfigEntry
	36, // 52: opensource.tab.cache_server.ControlData.default_experiment_metrics_config:type_name -> opensource.tab.cache_server.MetricsConfig
	57, // 53: opensource.tab.cache_server.ControlData.remote_config_metrics_config:type_name -> opensource.tab.cache_server.ControlData.RemoteConfigMetricsConfigEntry
	36, // 54: opensource.tab.cache_server.ControlData.default_remote_config_metrics_config:type_name -> opensource.tab.cache_server.MetricsConfig
	58, // 55: opensource.tab.cache_server.ControlData.feature_flag_metrics_config:type_name -> opensource.tab.cache_server.ControlData.FeatureFlagMetricsConfigEntry
	36, // 56: opensource.tab.cache_server.ControlData.default_feature_flag_metrics_config:type_name -> opensource.tab.cache_server.MetricsConfig
	36, // 57: opensource.tab.cache_server.ControlData.event_metrics_config:type_name -> opensource.tab.cache_server.MetricsConfig
	59, // 58: opensource.tab.cache_server.ControlData.metrics_init_config_index:type_name -> opensource.tab.cache_server.ControlData.MetricsInitConfigIndexEntry
	38, // 59: opensource.tab.cache_server.MetricsConfig.metadata:type_name -> opensource.tab.cache_server.MetricsMetadata
	60, // 60: opensource.tab.cache_server.MetricsInitConfig.kv:type_name -> opensource.tab.cache_server.MetricsInitConfig.KvEntry
	61, // 61: opensource.tab.cache_server.MetricsMetadata.expanded_data:type_name -> opensource.tab.cache_server.MetricsMetadata.ExpandedDataEntry
	30, // 62: opensource.tab.cache_server.TabConfig.experiment_data:type_name -> opensource.tab.cache_server.ExperimentData
	32, // 63: opensource.tab.cache_server.TabConfig.config_data:type_name -> opensource.tab.cache_server.RemoteConfigData
	35, // 64: opensource.tab.cache_server.TabConfig.control_data:type_name -> opensource.tab.cache_server.ControlData
	1,  // 65: opensource.tab.cache_server.TabConfigManager.update_type:type_name -> opensource.tab.cache_server.UpdateType
	39, // 66: opensource.tab.cache_server.TabConfigManager.tab_config:type_name -> opensource.tab.cache_server.TabConfig
	13, // 67: opensource.tab.cache_server.BucketInfo.bucket_type:type_name -> opensource.tab.cache_server.BucketType
	29, // 68: opensource.tab.cache_server.BucketInfo.traffic_range:type_name -> opensource.tab.cache_server.TrafficRange
	14, // 69: opensource.tab.cache_server.BucketInfo.modify_type:type_name -> opensource.tab.cache_server.ModifyType
	62, // 70: opensource.tab.cache_server.BatchGetExperimentBucketReq.bucket_version_index:type_name -> opensource.tab.cache_server.BatchGetExperimentBucketReq.BucketVersionIndexEntry
	2,  // 71: opensource.tab.cache_server.BatchGetExperimentBucketResp.code:type_name -> opensource.tab.cache_server.Code
	63, // 72: opensource.tab.cache_server.BatchGetExperimentBucketResp.bucketIndex:type_name -> opensource.tab.cache_server.BatchGetExperimentBucketResp.BucketIndexEntry
	64, // 73: opensource.tab.cache_server.BatchGetGroupBucketReq.bucket_version_index:type_name -> opensource.tab.cache_server.BatchGetGroupBucketReq.BucketVersionIndexEntry
	2,  // 74: opensource.tab.cache_server.BatchGetGroupBucketResp.code:type_name -> opensource.tab.cache_server.Code
	65, // 75: opensource.tab.cache_server.BatchGetGroupBucketResp.bucketIndex:type_name -> opensource.tab.cache_server.BatchGetGroupBucketResp.BucketIndexEntry
	23, // 76: opensource.tab.cache_server.Layer.GroupIndexEntry.value:type_name -> opensource.tab.cache_server.Group
	20, // 77: opensource.tab.cache_server.Layer.ExperimentIndexEntry.value:type_name -> opensource.tab.cache_server.Experiment
	17, // 78: opensource.tab.cache_server.ExperimentData.OverrideListEntry.value:type_name -> opensource.tab.cache_server.LayerToGroupID
	19, // 79: opensource.tab.cache_server.HoldoutData.HoldoutLayerIndexEntry.value:type_name -> opensource.tab.cache_server.Layer
	33, // 80: opensource.tab.cache_server.RemoteConfigData.RemoteConfigIndexEntry.value:type_name -> opensource.tab.cache_server.RemoteConfig
	36, // 81: opensource.tab.cache_server.ControlData.ExperimentMetricsConfigEntry.value:type_name -> opensource.tab.cache_server.MetricsConfig
	36, // 82: opensource.tab.cache_server.ControlData.RemoteConfigMetricsConfigEntry.value:type_name -> opensource.tab.cache_server.MetricsConfig
	36, // 83: opensource.tab.cache_server.ControlData.FeatureFlagMetricsConfigEntry.value:type_name -> opensource.tab.cache_server.MetricsConfig
	37, // 84: opensource.tab.cache_server.ControlData.MetricsInitConfigIndexEntry.value:type_name -> opensource.tab.cache_server.MetricsInitConfig
	41, // 85: opensource.tab.cache_server.BatchGetExperimentBucketResp.BucketIndexEntry.value:type_name -> opensource.tab.cache_server.BucketInfo
	41, // 86: opensource.tab.cache_server.BatchGetGroupBucketResp.BucketIndexEntry.value:type_name -> opensource.tab.cache_server.BucketInfo
	15, // 87: opensource.tab.cache_server.APIServer.GetTabConfig:input_type -> opensource.tab.cache_server.GetTabConfigReq
	42, // 88: opensource.tab.cache_server.APIServer.BatchGetExperimentBucket:input_type -> opensource.tab.cache_server.BatchGetExperimentBucketReq
	44, // 89: opensource.tab.cache_server.APIServer.BatchGetGroupBucket:input_type -> opensource.tab.cache_server.BatchGetGroupBucketReq
	16, // 90: opensource.tab.cache_server.APIServer.GetTabConfig:output_type -> opensource.tab.cache_server.GetTabConfigResp
	43, // 91: opensource.tab.cache_server.APIServer.BatchGetExperimentBucket:output_type -> opensource.tab.cache_server.BatchGetExperimentBucketResp
	45, // 92: opensource.tab.cache_server.APIServer.BatchGetGroupBucket:output_type -> opensource.tab.cache_server.BatchGetGroupBucketResp
	90, // [90:93] is the sub-list for method output_type
	87, // [87:90] is the sub-list for method input_type
	87, // [87:87] is the sub-list for extension type_name
	87, // [87:87] is the sub-list for extension extendee
	0,  // [0:87] is the sub-list for field type_name
}

func init() { file_cache_server_proto_init() }
func file_cache_server_proto_init() {
	if File_cache_server_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_cache_server_proto_rawDesc), len(file_cache_server_proto_rawDesc)),
			NumEnums:      15,
			NumMessages:   51,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_cache_server_proto_goTypes,
		DependencyIndexes: file_cache_server_proto_depIdxs,
		EnumInfos:         file_cache_server_proto_enumTypes,
		MessageInfos:      file_cache_server_proto_msgTypes,
	}.Build()
	File_cache_server_proto = out.File
	file_cache_server_proto_goTypes = nil
	file_cache_server_proto_depIdxs = nil
}
